---
layout: post
title: Redis学习手册(实例代码)
---

<p> 在之前的博客中已经非常详细的介绍了Redis的各种操作命令、运行机制和服务器初始化参数配置。本篇博客是该系列博客中的最后一篇，在这里将给出基于Redis客户端组件访问并操作Redis服务器的代码示例。然而需要说明的是，由于Redis官方并未提供基于C接口的Windows平台客户端，因此下面的示例仅可运行于Linux/Unix平台。但是对于使用其它编程语言的开发者而言，如C#和Java，Redis则提供了针对这些语言的客户端组件，通过该方式，同样可以达到基于Windows平台与Redis服务器进行各种交互的目的。 该篇博客中使用的客户端来自于Redis官方网站，是Redis推荐的基于C接口的客户端组件，见如下链接： https://github.com/antirez/hiredis 在下面的代码示例中，将给出两种最为常用的Redis命令操作方式，既普通调用方式和基于管线的调用方式。 <em>注：在阅读代码时请留意注释。</em></p><pre>  1 #include &lt;stdio.h&gt;  2 #include &lt;stdlib.h&gt;  3 #include &lt;stddef.h&gt;  4 #include &lt;stdarg.h&gt;  5 #include &lt;string.h&gt;  6 #include &lt;assert.h&gt;  7 #include &lt;hiredis.h&gt;  8   9 void doTest() 10 { 11     int timeout = 10000; 12     struct timeval tv; 13     tv.tv_sec = timeout / 1000; 14     tv.tv_usec = timeout * 1000; 15     //以带有超时的方式链接Redis服务器，同时获取与Redis连接的上下文对象。 16     //该对象将用于其后所有与Redis操作的函数。 17     redisContext* c = redisConnectWithTimeout("192.168.149.137",6379,tv); 18     if (c-&gt;err) { 19         redisFree(c); 20         return; 21     } 22     const char* command1 = "set stest1 value1"; 23     redisReply* r = (redisReply*)redisCommand(c,command1); 24     //需要注意的是，如果返回的对象是NULL，则表示客户端和服务器之间出现严重错误，必须重新链接。 25     //这里只是举例说明，简便起见，后面的命令就不再做这样的判断了。 26     if (NULL == r) { 27         redisFree(c); 28         return; 29     } 30     //不同的Redis命令返回的数据类型不同，在获取之前需要先判断它的实际类型。 31     //至于各种命令的返回值信息，可以参考Redis的官方文档，或者查看该系列博客的前几篇 32     //有关Redis各种数据类型的博客。:) 33     //字符串类型的set命令的返回值的类型是REDIS_REPLY_STATUS，然后只有当返回信息是"OK" 34     //时，才表示该命令执行成功。后面的例子以此类推，就不再过多赘述了。 35     if (!(r-&gt;type == REDIS_REPLY_STATUS &amp;&amp; strcasecmp(r-&gt;str,"OK") == 0)) { 36         printf("Failed to execute command[%s].\n",command1); 37         freeReplyObject(r); 38         redisFree(c); 39         return; 40     } 41     //由于后面重复使用该变量，所以需要提前释放，否则内存泄漏。 42     freeReplyObject(r); 43     printf("Succeed to execute command[%s].\n",command1); 44  45     const char* command2 = "strlen stest1"; 46     r = (redisReply*)redisCommand(c,command2); 47     if (r-&gt;type != REDIS_REPLY_INTEGER) { 48         printf("Failed to execute command[%s].\n",command2); 49         freeReplyObject(r); 50         redisFree(c); 51         return; 52     } 53     int length = r-&gt;integer; 54     freeReplyObject(r); 55     printf("The length of 'stest1' is %d.\n",length); 56     printf("Succeed to execute command[%s].\n",command2); 57  58     const char* command3 = "get stest1"; 59     r = (redisReply*)redisCommand(c,command3); 60     if (r-&gt;type != REDIS_REPLY_STRING) { 61         printf("Failed to execute command[%s].\n",command3); 62         freeReplyObject(r); 63         redisFree(c); 64         return; 65     } 66     printf("The value of 'stest1' is %s.\n",r-&gt;str); 67     freeReplyObject(r); 68     printf("Succeed to execute command[%s].\n",command3); 69  70     const char* command4 = "get stest2"; 71     r = (redisReply*)redisCommand(c,command4); 72     //这里需要先说明一下，由于stest2键并不存在，因此Redis会返回空结果，这里只是为了演示。 73     if (r-&gt;type != REDIS_REPLY_NIL) { 74         printf("Failed to execute command[%s].\n",command4); 75         freeReplyObject(r); 76         redisFree(c); 77         return; 78     } 79     freeReplyObject(r); 80     printf("Succeed to execute command[%s].\n",command4); 81  82     const char* command5 = "mget stest1 stest2"; 83     r = (redisReply*)redisCommand(c,command5); 84     //不论stest2存在与否，Redis都会给出结果，只是第二个值为nil。 85     //由于有多个值返回，因为返回应答的类型是数组类型。 86     if (r-&gt;type != REDIS_REPLY_ARRAY) { 87         printf("Failed to execute command[%s].\n",command5); 88         freeReplyObject(r); 89         redisFree(c); 90         //r-&gt;elements表示子元素的数量，不管请求的key是否存在，该值都等于请求是键的数量。 91         assert(2 == r-&gt;elements); 92         return; 93     } 94     for (int i = 0; i &lt; r-&gt;elements; ++i) { 95         redisReply* childReply = r-&gt;element[i]; 96         //之前已经介绍过，get命令返回的数据类型是string。 97         //对于不存在key的返回值，其类型为REDIS_REPLY_NIL。 98         if (childReply-&gt;type == REDIS_REPLY_STRING) 99             printf("The value is %s.\n",childReply-&gt;str);100     }101     //对于每一个子应答，无需使用者单独释放，只需释放最外部的redisReply即可。102     freeReplyObject(r);103     printf("Succeed to execute command[%s].\n",command5);104 105     printf("Begin to test pipeline.\n");106     //该命令只是将待发送的命令写入到上下文对象的输出缓冲区中，直到调用后面的107     //redisGetReply命令才会批量将缓冲区中的命令写出到Redis服务器。这样可以108     //有效的减少客户端与服务器之间的同步等候时间，以及网络IO引起的延迟。109     //至于管线的具体性能优势，可以考虑该系列博客中的管线主题。110     if (REDIS_OK != redisAppendCommand(c,command1)111         || REDIS_OK != redisAppendCommand(c,command2)112         || REDIS_OK != redisAppendCommand(c,command3)113         || REDIS_OK != redisAppendCommand(c,command4)114         || REDIS_OK != redisAppendCommand(c,command5)) {115         redisFree(c);116         return;117     }118 119     redisReply* reply = NULL;120     //对pipeline返回结果的处理方式，和前面代码的处理方式完全一直，这里就不再重复给出了。121     if (REDIS_OK != redisGetReply(c,(void**)&amp;reply)) {122         printf("Failed to execute command[%s] with Pipeline.\n",command1);123         freeReplyObject(reply);124         redisFree(c);125     }126     freeReplyObject(reply);127     printf("Succeed to execute command[%s] with Pipeline.\n",command1);128 129     if (REDIS_OK != redisGetReply(c,(void**)&amp;reply)) {130         printf("Failed to execute command[%s] with Pipeline.\n",command2);131         freeReplyObject(reply);132         redisFree(c);133     }134     freeReplyObject(reply);135     printf("Succeed to execute command[%s] with Pipeline.\n",command2);136 137     if (REDIS_OK != redisGetReply(c,(void**)&amp;reply)) {138         printf("Failed to execute command[%s] with Pipeline.\n",command3);139         freeReplyObject(reply);140         redisFree(c);141     }142     freeReplyObject(reply);143     printf("Succeed to execute command[%s] with Pipeline.\n",command3);144 145     if (REDIS_OK != redisGetReply(c,(void**)&amp;reply)) {146         printf("Failed to execute command[%s] with Pipeline.\n",command4);147         freeReplyObject(reply);148         redisFree(c);149     }150     freeReplyObject(reply);151     printf("Succeed to execute command[%s] with Pipeline.\n",command4);152 153     if (REDIS_OK != redisGetReply(c,(void**)&amp;reply)) {154         printf("Failed to execute command[%s] with Pipeline.\n",command5);155         freeReplyObject(reply);156         redisFree(c);157     }158     freeReplyObject(reply);159     printf("Succeed to execute command[%s] with Pipeline.\n",command5);160     //由于所有通过pipeline提交的命令结果均已为返回，如果此时继续调用redisGetReply，161     //将会导致该函数阻塞并挂起当前线程，直到有新的通过管线提交的命令结果返回。162     //最后不要忘记在退出前释放当前连接的上下文对象。163     redisFree(c);164     return;165 }166 167 int main() 168 {169     doTest();170     return 0;171 }172 173 //输出结果如下：174 //Succeed to execute command[set stest1 value1].175 //The length of 'stest1' is 6.176 //Succeed to execute command[strlen stest1].177 //The value of 'stest1' is value1.178 //Succeed to execute command[get stest1].179 //Succeed to execute command[get stest2].180 //The value is value1.181 //Succeed to execute command[mget stest1 stest2].182 //Begin to test pipeline.183 //Succeed to execute command[set stest1 value1] with Pipeline.184 //Succeed to execute command[strlen stest1] with Pipeline.185 //Succeed to execute command[get stest1] with Pipeline.186 //Succeed to execute command[get stest2] with Pipeline.187 //Succeed to execute command[mget stest1 stest2] with Pipeline.</pre>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>