---
layout: post
title: JS文件加载优化 ControlJS
---

<p style="margin: 0px 0px 10px; padding: 0px;">ontrolJS 主要为了是解决网页加载中Js文件的性能问题，<strong style="padding: 0px; margin: 0px;">ControlJS的原理</p><p style="margin: 0px 0px 10px; padding: 0px;"></p><p style="margin: 0px 0px 10px; padding: 0px;">ControlJS本身是异步进行加载的，首先将script的标签type属性值更改为浏览器无法识别的类型，这样浏览器不会认为这是一个脚本。本身异 步加载的ControlJS执行时开始遍历type=&rdquo;text/cjs&rdquo;的script标签(包括内嵌脚本)，如果存在&rdquo;DATA-CJSSRC&rdquo;属性 将创建IMAGE或者OBJECT对象(依赖浏览器而选择)，去异步预下载脚本文件并缓存文件，直到window.onload时解析并执行 javascript，同时第二次去遍历遗漏的script标签。</p>异步加载<p>ControlJS本身是异步进行加载的，首先将script的标签type属性值更改为浏览器无法识别的类型，这样浏览器不会认为这是一个脚本。本身异步加载的ControlJS执行时开始遍历type=&rdquo;text/cjs&rdquo;的script标签(包括内嵌脚本)，如果存在&rdquo;DATA-CJSSRC&rdquo;属性将创建IMAGE或者OBJECT对象(依赖浏览器而选择)，去异步预下载脚本文件并缓存文件，直到window.onload时解析并执行javascript，同时第二次去遍历遗漏的script标签。具体操作可看Async WITH ControlJS</p><p>延迟执行</p><p>浏览器在解析执行javascript阶段是阻塞任何操作的，这时的浏览器处于假死状态，Steve分析了美国的Alexa前10名网站的脚本初始需要加载执行情况，发现只有29％是需要页面加载时初始化解析执行的，而其他71%的脚本是在触发交互时才会执行，压缩后这些脚本平均加载是229 kB，未压缩是500KB，这是个大量的数据。</p><p>我们希望的结果是在页面加载中不去解析执行javascript，只是提前预下载好文件。例如通用的点击弹出二级导航，用户有可能永远都没有点击导航的行为，此时导航的功能脚本根本毫无用处。但是人们在点击导航时不希望等太久javascript的执行，所以ControlJS会提前下载文件，这样javascript只是解析执行，不会花时间放到下载文件上。代码一目了然，具体操作可看Menu WITH ControlJS</p><p>重写document.write</p><p>在默认情况下这些异步脚本都是在window.onload解析执行，如果此时脚本调用window.write方法，将导致一个不希望发生的问题，就是整个页面被window.write的输出内容替换，所有页面内容将被删除，ie下将处于停滞状态。产生问题的原因是由于在document被加载完后调用docuemnt.write方法时将会自动去触发document.open,写入任何处于打开状态的doucment都将会会替换整个页面的内容。这便导致目前为止所有异步脚本无法延迟document.write的问题，ControlJS的处理方法是重写document.write，如下：</p><pre>CJS.docwriteOrig = document.write;document.write = CJS.docwrite;</pre><p>ControlJS创建一个dom元素(span)，将其插入当前被解析执行的script标签之前，并且设置SPAN的innerHTML的值为docuemnt.write的内容。具体操作可看document.write WITH ControlJS</p>用ControlJS优化阿里妈妈广告<p>对于现在大部分的广告形式都是采用document.write方式写入，无法将这些内容异步处理是开发者非常头疼的问题。ControlJS可以为我们解决这类烦恼。</p><p>没有应用ControlJS的网络图。DEMO可以看http://chesihui.github.com/ad-demo.html</p><p>应用ControlJS优化后的网络图。DEMO可以看http://chesihui.github.com/ControlJS-demo.html</p>ControlJS的局限性<p>ControlJS存在一个问题是在document.write中多层嵌套script标签时，页面仍然存在触发document.open的问题。查看源代码发现在执行完一个javascript后都会恢复document.write的原生方法：</p><pre>document.write = CJS.docwriteOrig;</pre><p>动态脚本的异步加载，同样使得document.write方法也是异步执行，因此不能恢复document.write的原生功能。复现的情况如DEMO。注释这段脚本虽然解决了不触发window.open的问题，但是同样的异步加载执行导致无法正确定位广告写入的位置。对于阿里妈妈广告设置alimama_type=&rdquo;i&rdquo;的时候，载入图片广告是根据多层document.write实现的，只能正确渲染最后一个图片广告。复现如DEMO。</p><p>因为ControlJS的异步加载不存在任何依赖顺序，所有脚本都是并行加载执行，如果你的页面存在太多依赖关系，ControlJS将不会适合你的项目。</p><p>最后总结ControlJS为我们做了什么事，利弊还需要自己去权衡：1、异步下载所有脚本2、同时处理内嵌与外链脚本3、延迟脚本的执行直到页面被渲染完4、允许脚本只下载不执行5、解决了异步脚本中存在document.write的问题6、ControlJS本身是异步加载</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>