---
layout: post
title: 修改修改boot.img文件的工具，mkbootfs,mkbootimg,unpackbootimg
---

<p>#编译mkbootfs,mkbootimg,unpackbootimg#首先要得到android_system_core的源代码，从github.com上面下载得到#其中要编译的三个文件分别位于CyanogenMod-android_system_core-***的目录里面的不同文件夹中。下面的代码是经过我修改的：</p><p>http://115.com/file/c25957co#</p><p>CyanogenMod-...m-core-sn.zip</p><p>其中mkbootfs的源代码位于cpio文件夹中mkbootimg和unpackbootimg位置mkbootimg文件夹中#使用的工具是linux系统的gccPS:如果需要交叉编译，就需要下载我制作的交叉编译器下面讲解一下编译的过程：一 讲解编译mkbootfs文件1.分析Android.mk(此文件位于cpio目录里面）目录路径如下：/home/username/CyangenMod-android_system_core-***(其中的*代表的是标识码）/cpio/Android.mk使用gedit打开此文件，得到的内容如下：----------cut here-----------------------# Copyright 2005 The Android Open Source Project</p><p>LOCAL_PATH:= $(call my-dir) #得到本目录的位置include $(CLEAR_VARS) #其中这句表示声明编译的开始。</p><p>LOCAL_SRC_FILES := \ #源代码文件mkbootfs.c</p><p>LOCAL_MODULE := mkbootfs #生成的文件名</p><p>include $(BUILD_HOST_EXECUTABLE) #生成在本机使用的可执行文件</p><p>$(call dist-for-goals,droid,$(LOCAL_BUILT_MODULE)) #这句就不知道是什么意思了--------------------------------------------------</p><p>2.制作自己使用的makefile从上面的Android.mk文件中得到如下的信息：编译用到的源代码文件是mkbootfs.c,生成的文件是一个可执行的文件，没有加入编译参数，生成的文件在本机运行。所以我制作的makefile如下所示：----------------cut here------------------------#makefile for arm-mkbootimg #create by sn</p><p>#arm-linux-androideabi- #这句是我在编译android版本的mkbootfs用到的。CC = $(CROSS_COMPILE)gccLD = $(CROSS_COMPILE)ldEXEC = arm-mkbootfsOBJ = mkbootfs.oSRC = mkbootfs.c$(EXEC):$(OBJ) ;$(CC) -o $@ $&lt;$(OBJ):$(SRC) ;$(CC) -fPIC -c -o $@ $&lt;</p><p>clean:rm -f $(OBJ) $(EXEC) </p><p>-------------------------------------------</p><p>--------------------------------------------------3.查看源代码中的头文件关链问题。/*mkbootfs.c */中的头文件声明问题如下------------------cut here-----------------#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;</p><p>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;dirent.h&gt;</p><p>#include &lt;stdarg.h&gt;#include &lt;fcntl.h&gt;</p><p>#include &lt;private/android_filesystem_config.h&gt;--------------------------------------------为了能让编译通过，得修改最后一个头文件声明位置，修改为如下：---------------#include "android_filesystem_config.h" -------------------------------------最后要做的是，把CyangenMod-android_system_core-**/include/private/android_filesystem_config.h文件复制到当前的目录即是CygenMod-android_system_core-**/cpio目录里面。4.在终端里面使用make，来编译生成mkbootfs5.如果需要交叉编译的，就把makefile中的CROSS_COMPILE = #这句补充完整。</p><p>二 编译mkbootimg和unpackbootimg1.分析mkbootimg文件夹中的Android.mk文件-------------------cut here--------------LOCAL_PATH:= $(call my-dir) #这句是声明当前的目录include $(CLEAR_VARS)</p><p>LOCAL_SRC_FILES := mkbootimg.c #要用到的源代码是mkbootimg.cLOCAL_STATIC_LIBRARIES := libmincrypt #此句声明要使用的静态库文件是libmincrypt.a</p><p>LOCAL_MODULE := mkbootimg</p><p>include $(BUILD_HOST_EXECUTABLE) #上当的内容是编译mkbootimg的命令。</p><p>include $(CLEAR_VARS) #从这里开始到是编译unpackbootimg的部分LOCAL_MODULE_TAGS := engLOCAL_SRC_FILES := unpackbootimg.cLOCAL_MODULE := unpackbootimginclude $(BUILD_HOST_EXECUTABLE) #编译unpackbootimg的部分</p><p>include $(CLEAR_VARS) #下面的部分也是编译mkbootimg和unpackbootimg的，但是加载的库文件就多了一个libcutils.so。所以我主要要上面的部分为规则。LOCAL_SRC_FILES := mkbootimg.cLOCAL_STATIC_LIBRARIES := libmincrypt libcutils libcLOCAL_MODULE := utility_mkbootimgLOCAL_MODULE_STEM := mkbootimgLOCAL_MODULE_CLASS := UTILITY_EXECUTABLESLOCAL_UNSTRIPPED_PATH := $(PRODUCT_OUT)/symbols/utilitiesLOCAL_MODULE_PATH := $(PRODUCT_OUT)/utilitiesLOCAL_FORCE_STATIC_EXECUTABLE := trueLOCAL_MODULE_TAGS := enginclude $(BUILD_EXECUTABLE)</p><p>include $(CLEAR_VARS)LOCAL_SRC_FILES := unpackbootimg.cLOCAL_STATIC_LIBRARIES := libcutils libcLOCAL_MODULE := utility_unpackbootimgLOCAL_MODULE_TAGS := engLOCAL_MODULE_STEM := unpackbootimgLOCAL_MODULE_CLASS := UTILITY_EXECUTABLESLOCAL_UNSTRIPPED_PATH := $(PRODUCT_OUT)/symbols/utilitiesLOCAL_MODULE_PATH := $(PRODUCT_OUT)/utilitiesLOCAL_FORCE_STATIC_EXECUTABLE := trueinclude $(BUILD_EXECUTABLE)</p><p>$(call dist-for-goals,droid,$(LOCAL_BUILT_MODULE))---------------------------------------2.根据Android.mk文件得要的如下的内容，在编译的过程中都需要加载静态库libmincrypt.a文件。找了一找系统目录，没有发现这个文件，再在/CyanogenMod-android_system_core-**/libmincrypt/Android.mk文件中得到了如下的信息：--------------------cut here------------# Copyright 2008 The Android Open Source Project#LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)</p><p>LOCAL_MODULE := libmincrypt LOCAL_SRC_FILES := rsa.c sha.cinclude $(BUILD_STATIC_LIBRARY)</p><p>include $(CLEAR_VARS)</p><p>LOCAL_MODULE := libmincrypt #还有这句LOCAL_MODULE := libmincryptLOCAL_SRC_FILES := rsa.c sha.cinclude $(BUILD_HOST_STATIC_LIBRARY) #生成主机使用的静态库#include $(BUILD_HOST_STATIC_LIBRARY) </p><p># TODO: drop the hyphen once these are checked ininclude $(LOCAL_PATH)/tools/Android.mk</p><p>----------------------------------------------为了编译这个mkbootimg和unpackbootimg，首先要编译得到libmincrypt.a2.1以下的内容是编译libmincrypt.a的过程： 从刚刚的libmincrypt/Android.mk可以得到如下的信息：需要的源代码文件是：rsa.c sha.c分析rsa.c和sha.c的源代码，得到了共同的头文件声明如下：------------------cut here---------------/*rsa.c or sha.c */#include "mincrypt/rsa.h"#include "mincrypt/sha.h"-----------------------------在文件的声明中，得知了，需要用到的头文件在/include/mincrypt/目录中所以需要把/CyanogenMod-android_system_core-***/include/mincrypt/目录复制到当前的目录即是/libmincrypt2.2制作自己的makefile文件-------------------cut here---------------#make file build for libmincrypt.a#create by snCROSS_COMPILE = #arm-linux-androideabi-CC = $(CROSS_COMPILE)gccLD = $(CROSS_COMPILE)ldAR = $(CROSS_COMPILE)arSTATIC_LIB = libmincrypt.aOBJ =rsa.o sha.o$(STATIC_LIB):$(OBJ);$(AR) -r $(STATIC_LIB) $(OBJ) rsa.o:rsa.c;$(CC) -c -o $@ $&lt;</p><p>sha.o:sha.c;$(CC) -c -o $@ $&lt;</p><p>clean:rm -f $(STATIC_LIB) $(OBJ) ----------------------------------------</p><p>根据文件关链，写的makefile如上所示。在终端里面进入当前的目录/libmincrypt 再执行make,来编译生成libmincrypt.a 文件。把编译得到的文件复制到/mkbootimg目录下面。以备用。3.在第二步中已经得到了libmincrypt.a文件。下面就开始制作makefile,并编译mkbootimg,unpackbootimg</p><p>-----------------------cut here---------------------#make for build mkbootimg #create by sn 2012-5-23 21:14:18CROSS_COMPILE = #arm-linux-androideabi-CC = $(CROSS_COMPILE)gccLD = $(CROSS_COMPILE)ldLDCFLAGES =STATIC_LIB = libmincrypt.a#MKBOOTIMG_TARGET = arm-mkbootimgMKBOOTIMG_OBJ = mkbootimg.oMKBOOTIMG_SRC = mkbootimg.c#UNPACKBOOT_TARGET = arm-unpackbootimgUNPACKBOOTIMG_OBJ = unpackbootimg.oUNPACKBOOTIMG_SRC = unpackbootimg.call:mkbootimg mkbootimg:$(MKBOOTIMG_OBJ);$(CC) -o $@ $&lt; $(STATIC_LIB)</p><p>$(MKBOOTIMG_OBJ):$(MKBOOTIMG_SRC);$(CC) -c $&lt;unpackboot:unpackbootimgunpackbootimg:$(UNPACKBOOTIMG_OBJ);$(CC) -o $@ $&lt; $(STATIC_LIB)$(UNPACKBOOTIMG_OBJ):$(UNPACKBOOTIMG_SRC);$(CC) -c $&lt;</p><p>clean:rm -f mkbootimg unpackbootimg $(MKBOOTIMG_OBJ) $(UNPACKBOOTIMG_OBJ) -------------------------------------------------这个makefile主要是定义了编译的对象和编译的方法。还有编译的规则。在输入make all编译的时候，得到的文件是mkbootimg输入make unpackboot编译得到unpackbootimg</p><p>二.在同一个文件夹中编译所有的文件(mkbootfs,mkbootimg,unpackbootimg)我选择的工作目录是/mkbootimg1。复制需要的文件在../include目录中复制mincrypt目录到当前目录（mkbootimg)在../libmincrypt目录中复制sha.c rsa.c文件到当前目录在../cpio目录中复制mkbootfs.c #此文件在一中已经经过修改。在../include/private目录中复制android_filesystem_config.h头文件到当前目录。在复制完成后。当前目录的结构如下：./mincrypt/sha.h./mincrypt/rsa.h./Android.mk./android_filesystem_config.h./bootimg.h./mkbootfs.c./mkbootimg.c./unpackbootimg.c./rsa.c./sha.c./unpackbootimg.c./makefile # 此文件需要自己创建</p><p>2.制作自己的makefile下面是我编写好的makefile-----------------------------cut here----------------------------#make for build mkbootimg #create by sn 2012-5-23 21:14:18CROSS_COMPILE = #arm-linux-androideabi-CC = $(CROSS_COMPILE)gccLD = $(CROSS_COMPILE)ldAR = $(CROSS_COMPILE)arLDCFLAGES =STATIC_LIB = libmincrypt.a#MKBOOTIMG_TARGET = arm-mkbootimgMKBOOTIMG_OBJ = mkbootimg.oMKBOOTIMG_SRC = mkbootimg.c#UNPACKBOOT_TARGET = arm-unpackbootimgUNPACKBOOTIMG_OBJ = unpackbootimg.oUNPACKBOOTIMG_SRC = unpackbootimg.cLIBMINCRYPT_OBJ = sha.o rsa.oSHA_SRC = sha.cRSA_SRC = rsa.cMKBOOTFS_OBJ = mkbootfs.oMKBOOTFS_SRC = mkbootfs.call:mkbootimg #此处定义编译mkbootimgmkbootimg:$(MKBOOTIMG_OBJ);$(CC) -o $@ $&lt; $(STATIC_LIB)</p><p>$(MKBOOTIMG_OBJ):$(MKBOOTIMG_SRC);$(CC) -c $&lt;</p><p>unpackboot:unpackbootimg #此处定义编译unpackbootimgunpackbootimg:$(UNPACKBOOTIMG_OBJ);$(CC) -o $@ $&lt; $(STATIC_LIB)$(UNPACKBOOTIMG_OBJ):$(UNPACKBOOTIMG_SRC);$(CC) -c $&lt;</p><p>lib:libmincrypt.a #此处定义编译libmincrypt.alibmincrypt.a:$(LIBMINCRYPT_OBJ);$(AR) -r $(STATIC_LIB) $(LIBMINCRYPT_OBJ) sha.o:$(SHA_SRC);$(CC) -c -fPIC $&lt;rsa.o:$(RSA_SRC);$(CC) -c -fPIC $&lt;</p><p>mkboot:mkbootfs #此处定义了编译mkbootfsmkbootfs:$(MKBOOTFS_OBJ);$(CC) -o $@ $&lt;$(MKBOOTFS_OBJ):$(MKBOOTFS_SRC);$(CC) -c $&lt;</p><p>clean: #此处定义了要清除的文件rm -f mkbootfs mkbootimg unpackbootimg $(MKBOOTIMG_OBJ) $(UNPACKBOOTIMG_OBJ) $(LIBMINCRYPT_OBJ) $(STATIC_LIB) $(MKBOOTFS_OBJ) </p><p>-------------------------------------------------3.编译简单说一说编译的方法。因为这个mkbootimg和unpackbootimg都依赖于libmincrypt.a，所以在编译mkbootimg和unpackbootimg之前要先编译这个libmicrypt.a方法如下 ：3.1先执行make lib #此条命令是生成libmincrypt.a再执行make all #此条命令是生成mkbootimg再执行make unpackboot #此条命令是生成unpackbootimg再后执行的是make mkboot #此条命令可以在最前执行，也可以在最后执行。因为这个mkbootfs没有依赖于libmincrypt.a3.2最后总结一下就是。没有什么是不可能的。只要肯努力就行了。 </p><p>下面提供的是我已经编译好的工具：</p><p>http://115.com/file/dptqtena#</p><p>make-mkboot-tools.rar</p><p>下面是编译后的图片：绿色表示生成的可执行文件。</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>