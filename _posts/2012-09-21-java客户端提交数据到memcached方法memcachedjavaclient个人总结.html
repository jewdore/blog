---
layout: post
title: java客户端提交数据到memcached方法memcached+java+client个人总结
---

<p>终于把nginx+memcached+tomcat集群windows下布置完成，但是遇到java客户端提交数据到memcached的问题，上网看了好多人的帖子，发现了3种方法</p><p>1. 三种API比较 1) memcached client for java</p><p>较早推出的memcached JAVA客户端API，应用广泛，运行比较稳定。</p><p>2) spymemcached</p><p>A simple, asynchronous, single-threaded memcached client written in java. 支持异步，单线程的memcached客户端，用到了java1.5版本的concurrent和nio，存取速度会高于前者，但是稳定性不好，测试中常报timeOut等相关异常。</p><p>3) xmemcached</p><p>XMemcached 同样是基于java nio的客户端，java nio相比于传统阻塞io模型来说，有效率高（特别在高并发下）和资源耗费相对较少的优点。传统阻塞IO为了提高效率，需要创建一定数量的连接形成连接池，而nio仅需要一个连接即可（当然,nio也是可以做池化处理），相对来说减少了线程创建和切换的开销，这一点在高并发下特别明显。因此 XMemcached与Spymemcached在性能都非常优秀，在某些方面（存储的数据比较小的情况下）Xmemcached比 Spymemcached的表现更为优秀，具体可以看这个Java Memcached Clients Benchmark。</p><p>2. 建议</p><p>由于memcached client for java发布了新版本，性能上有所提高，并且运行稳定，所以建议使用memcached client for java。</p><p>XMemcached 也使用得比较广泛，而且有较详细的中文API文档，具有如下特点：高性能、支持完整的协议、支持客户端分布、允许设置节点权重、动态增删节点、支持 JMX、与Spring框架和Hibernate-memcached的集成、客户端连接池、可扩展性好等。</p><p>我使用的是建议方法memcached client for java，</p><p>Memcached-Java-Client官网jar包的下载地址：</p><p>https://github.com/gwhalin/Memcached-Java-Client/downloads</p><p>Memcached-Java-Client的说明文档：</p><p>https://github.com/gwhalin/Memcached-Java-Client</p><p>具体实现步骤为：</p><p>1.将jar包引入项目中，我引入了4个commons-pool-1.5.6.jar,java_memcached-release_2.6.2.jar,slf4j-api-1.6.1.jar,slf4j-simple-1.6.1.jar</p><p>2.写测试代码：</p><pre class="brush:java;gutter:false;">import java.util.Date;import com.danga.MemCached.MemCachedClient;import com.danga.MemCached.SockIOPool;/*** 使用memcached的缓存实用类.* * @author 原作者：铁木箱子  完善：周枫**/public class MemCached{    // 创建全局的唯一实例    protected static MemCachedClient mcc = new MemCachedClient();        protected static MemCached memCached = new MemCached();        // 设置与缓存服务器的连接池    static {        // 服务器列表和其权重，个人memcached地址和端口号        String[] servers = {"192.168.88.137:11211"};        Integer[] weights = {3};        // 获取socke连接池的实例对象        SockIOPool pool = SockIOPool.getInstance();        // 设置服务器信息        pool.setServers( servers );        pool.setWeights( weights );        // 设置初始连接数、最小和最大连接数以及最大处理时间        pool.setInitConn( 5 );        pool.setMinConn( 5 );        pool.setMaxConn( 250 );        pool.setMaxIdle( 1000 * 60 * 60 * 6 );        // 设置主线程的睡眠时间        pool.setMaintSleep( 30 );        // 设置TCP的参数，连接超时等        pool.setNagle( false );        pool.setSocketTO( 3000 );        pool.setSocketConnectTO( 0 );        // 初始化连接池        pool.initialize();           }        /**     * 保护型构造方法，不允许实例化！     *     */    protected MemCached()    {            }        /**     * 获取唯一实例.     * @return     */    public static MemCached getInstance()    {        return memCached;    }        /**     * 添加一个指定的值到缓存中.     * @param key     * @param value     * @return     */    public boolean add(String key, Object value)    {        return mcc.add(key, value);    }        public boolean add(String key, Object value, Date expiry)    {        return mcc.add(key, value, expiry);    }        /**     * 替换一个指定的值到缓存中.     * @param key     * @param value     * @return     */    public boolean replace(String key, Object value)    {        return mcc.replace(key, value);    }        public boolean replace(String key, Object value, Date expiry)    {        return mcc.replace(key, value, expiry);    }        /**     * 删除一个指定的值到缓存中.     * @param key     * @param value     * @return     */    public boolean delete(String key)    {    return mcc.delete(key);    }            /**     * 根据指定的关键字获取对象.     * @param key     * @return     */    public Object get(String key)    {        return mcc.get(key);    }        public static void main(String[] args)    {        MemCached cache = MemCached.getInstance();        //cache.add("zf", 18);        //cache.replace("zf", 19);        cache.delete("zf");        System.out.println("zf get value : " + cache.get("zf"));    }}</pre>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>