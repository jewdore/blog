---
layout: post
title: as3-signals的使用介绍
---

<p>as3-signals，一个as3开源库，地址：https://github.com/robertpenner/as3-signals/downloads，主要功能相当于as3中的事件，但实现起来比as3自带事件机制要简单，据说运行效率是其4倍！</p><p>在as3中自定义类，且要发送自定义事件，有两种方法：</p><p>第一就是自定义类继承EventDispatcher类或者实现IEventDispatcher接口</p><p>第二就是用组合的方式，在自定义类中，实例化一个可以发送事件的对象，这个对象当然必须也是继承自EventDispatcher或者实现IEventDispatcher接口</p><p>所以，as3中要发送事件，必须跟EventDispatcher类或者IEventDispatcher接口扯上关系，而自定义事件，必须继承自Event类，如果你在运行中此事件需要转发，还得重写Event类中的clone方法。</p><p>如果使用as3-signals这一切将会变得简单，不用自定义事件，也不用与EventDispatcher类或者IEventDispatcher接口有关系，但必须使用组合的方式使用as3-signals，即：将Signal的实例组合到需发事件的自定义类中。下面详细说一下：</p><p>先写一个自定义数据类型UserVo：</p><p>package vo</p><p>{</p><p> importflash.display.Sprite;</p><p> publicclass UserVo</p><p> {</p><p> publicvar userName:String;</p><p> publicvar age:int;</p><p> publicvar foods:Array = [3,2,3,4,new Sprite()];</p><p> publicfunction UserVo()</p><p> {</p><p> }</p><p> }</p><p>}</p><p>第一种常用情况，发送不带任何参数的事件，即不发送as3事件机制中的事件对象。</p><p>自定义类：Rect，此类需要发送事件(信号)的，但我们不继承EventDispatcher也不实现IEventDispatcher接口。</p><p>package view</p><p>{</p><p> importflash.display.Sprite;</p><p> importsignals.ClickSignal;</p><p> importvo.UserVo;</p><p> publicclass Rect extends Sprite</p><p> {</p><p> publicvar clickSignal:ClickSignal;</p><p> publicfunction Rect()</p><p> {</p><p> super();</p><p> clickSignal= new ClickSignal();</p><p> }</p><p> publicfunction click():void</p><p> {</p><p> clickSignal.dispatch();</p><p> }</p><p> }</p><p>}</p><p>clickSignal是用组合方式添加的事件(信号)，click方法用于发送事件(信号）。使用方法：</p><p>public function SignalsTest()</p><p>{</p><p> varrect:Rect = new Rect();</p><p> rect.clickSignal.add(onClick);</p><p> rect.click();</p><p>}</p><p>private function onClick():void</p><p>{</p><p> trace("onClick");</p><p>}</p><p>onClick函数是事件的监听函数。它不带任何参数。</p><p>第二种常用情况，发送带参数的信号(事件)</p><p>修改Rect类，如下：</p><p>package view</p><p>{</p><p> importflash.display.Sprite;</p><p> importsignals.ClickSignal;</p><p> importvo.UserVo;</p><p> publicclass Rect extends Sprite</p><p> {</p><p> publicvar clickSignal:ClickSignal;</p><p> publicfunction Rect()</p><p> {</p><p> super();</p><p> clickSignal= new ClickSignal(Number,String,Boolean,Object);</p><p> }</p><p> publicfunction click():void</p><p> {</p><p> clickSignal.dispatch(4,"sdfdsfdsfds",Boolean(3),newUserVo());</p><p> }</p><p> }</p><p>}</p><p>在ClickSignal构造函数中，传入类名称：Number，String，Boolean，Object，表示ClickSignal事件会带有4个参数，数据类型分别是Number，String，Boolean，Object类型，</p><p>如果有更多的参数，还可以继续在构造函数中的参数中增加下去，但是调用clickSignal.dispatch()方法时，参数顺序，数据类型，个数必须跟构造函数一一对应。使用方法如下：</p><p>public function SignalsTest()</p><p>{</p><p> varrect:Rect = new Rect();</p><p> rect.clickSignal.add(onClick);</p><p> rect.click();</p><p>}</p><p>private functiononClick(a:Number,b:String,c:Boolean,d:Object):void</p><p>{</p><p> trace(dis UserVo);//true</p><p> trace(d.foodsis Array);//true</p><p> trace(d.foods[4].name,Sprite(d.foods[4]).loaderInfo);//instance2null</p><p> trace("onClick==&gt;",a,b,c,d);//onClick==&gt;4 sdfdsfdsfds true [object UserVo]</p><p>}</p><p>上面的例子中，我们只知道了事件带有的参数，但并不清楚事件是谁发出来的，下面的例子即解决这个问题，下面要用到DeluxeSignal和GenericEvent类，他会作为一个事件对象传递给事件接收</p><p>函数，在此事件对象中包含了事件的目标！</p><p>新建自定义类：Circle，如下：</p><p>package view</p><p>{</p><p> importflash.display.Sprite;</p><p> importorg.osflash.signals.DeluxeSignal;</p><p> importorg.osflash.signals.events.GenericEvent;</p><p> publicclass Circle extends Sprite</p><p> {</p><p> publicvar signal:DeluxeSignal;</p><p> publicfunction Circle()</p><p> {</p><p> signal= new DeluxeSignal(this);</p><p> }</p><p> publicfunction dispatch():void</p><p> {</p><p> signal.dispatch(newGenericEvent(),4,"6666666666");</p><p> }</p><p> }</p><p>}</p><p>DeluxeSignal构造函数中传入的参数将会被作为事件的目标存入事件对象中(即：GenericEvent对象)。DeluxeSignal类包含了Signal类所有功能，所以发送DeluxeSignal事件(信号)也是可以自定义参数的。</p><p>signal.dispatch(newGenericEvent(),4,"6666666666");</p><p>dispatch方法有三个参数：</p><p>第一个：GenericEvent对象，包含了事件的目标，是否冒泡等信息</p><p>第二个,第三个...:是附带的参数，可以有多个参数，只需要继续往后面添加即可。</p><p>具体使用方法如下：</p><p>public function SignalsTest()</p><p>{</p><p> varcircle:Circle = new Circle();</p><p> circle.signal.add(onDispatch);</p><p> circle.dispatch();</p><p>}</p><p>private functiononDispatch(e:GenericEvent,a:Number,b:String):void</p><p>{</p><p> trace(e.signal);//[objectDeluxeSignal]</p><p> trace(e.currentTarget,e.target);//[objectCircle] [object Circle]</p><p> trace(a,b);//46666666666</p><p>}</p><p>第三种常用情况，简化as3自带的事件。</p><p>自定义类Native,当被添加到舞台时，绘制一个矩形，当被点击时，重绘矩形。</p><p>package view</p><p>{</p><p> importflash.display.Sprite;</p><p> importflash.events.Event;</p><p> importflash.events.MouseEvent;</p><p> importorg.osflash.signals.natives.NativeSignal;</p><p> publicclass Native extends Sprite</p><p> {</p><p> privatevar nativeSignal:NativeSignal;</p><p> privatevar clickSignal:NativeSignal;</p><p> publicfunction Native()</p><p> {</p><p> nativeSignal= new NativeSignal(this,Event.ADDEDE_TO_STAG,Event);</p><p> nativeSignal.addOnce(draw);</p><p> clickSignal= new NativeSignal(this,MouseEvent.CLICK,MouseEvent);</p><p> clickSignal.add(onClick);</p><p> }</p><p> privatefunction draw(e:Event):void</p><p> {</p><p> this.graphics.clear();</p><p> this.graphics.beginFill(0x0000ff,0.5);</p><p> this.graphics.drawRect(0,0,200,150);</p><p> this.graphics.endFill();</p><p> }</p><p> privatefunction onClick(e:MouseEvent):void</p><p> {</p><p> this.graphics.clear();</p><p> this.graphics.beginFill(Math.random()*0xffffff,0.5);</p><p> this.graphics.drawRect(0,0,200,150);</p><p> this.graphics.endFill();</p><p> }</p><p> }</p><p>}</p><p>NativeSignal类负责监听系统事件如：Event.ADDEDE_TO_STAG,MouseEvent.CLICK等，</p><p>add方法有三个参数可以填：1.事件目标；2.事件类型；3.事件类名称</p><p>调用clickSignal.add(onClick);后，当鼠标点击时，即会执行onClick函数。</p><p>有关更多as3-signals的介绍可以看下面的链接：</p><p>http://www.developria.com/2010/10/an-introduction-to-as3-signals.html</p><p>https://github.com/robertpenner/as3-signals/downloads</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>