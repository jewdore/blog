---
layout: post
title: MongoDB深究之ObjectId
---

<p class="MsoNormal" align="center" style="margin-bottom: 7.8pt; text-align: left;">   继上一篇《MongoDB初窥》之后，想必大家对自动生成的主键objectId有所好奇，为什么会是一个24位的字符串。今天，就对objectId的生成原理做一次比较深入的挖掘。</p><p class="MsoNormal" style="layout-grid-mode: char; mso-layout-grid-align: none;"><o:p></o:p>一、ObjectId的组成</p><p class="MsoNormal" style="text-indent: 21.0pt; layout-grid-mode: char; mso-layout-grid-align: none;">首先通过终端命令行，向mongodb的collection中插入一条不带&ldquo;_id&rdquo;的记录。然后，通过查询刚插入的数据，发现自动生成了一个objectId，4e7020cb7cac81af7136236b。具体操作如图1所示。</p><p class="MsoNormal" align="center" style="text-align: center; layout-grid-mode: char; mso-layout-grid-align: none;">图1 插入/查询数据</p><p class="MsoNormal" style="text-indent: 21.0pt; layout-grid-mode: char; mso-layout-grid-align: none;">&ldquo;4e7020cb7cac81af7136236b&rdquo;这个24位的字符串，虽然看起来很长，也很难理解，但实际上它是由一组十六进制的字符构成，每个字节两位的十六进制数字，总共用了12字节的存储空间。相比MYSQLint类型的4个字节，MongoDB确实多出了很多字节。不过按照现在的存储设备，多出来的字节应该不会成为什么瓶颈。不过MongoDB的这种设计，体现着空间换时间的思想。官网中对ObjectId的规范，如图2所示。</p><p class="MsoNormal" align="center" style="text-align: center; layout-grid-mode: char; mso-layout-grid-align: none;">图2 官网对ObjectId的规范</p><p class="MsoNormal" style="margin-left: 39.0pt; text-indent: -18.0pt; mso-list: l2 level1 lfo3; layout-grid-mode: char; mso-layout-grid-align: none;"><!--[if !supportLists]-->1) <!--[endif]-->Time<o:p></o:p></p><p class="MsoNormal" style="text-indent: 21.0pt; layout-grid-mode: char; mso-layout-grid-align: none;">时间戳。将刚才生成的objectid的前4位进行提取&ldquo;4e7020cb&rdquo;，然后按照十六进制转为十进制，变为&ldquo;1315971275&rdquo;，这个数字就是一个时间戳。通过时间戳的转换，就成了易看清的时间格式，如图3所示。</p><p class="MsoNormal" align="center" style="text-align: center; layout-grid-mode: char; mso-layout-grid-align: none;">图3 时间戳的转换</p><p class="MsoNormal" style="margin-left: 39.0pt; text-indent: -18.0pt; mso-list: l2 level1 lfo3; layout-grid-mode: char; mso-layout-grid-align: none;"><!--[if !supportLists]-->2) <!--[endif]-->Machine<o:p></o:p></p><p class="MsoNormal" style="text-indent: 21.0pt; layout-grid-mode: char; mso-layout-grid-align: none;">机器。接下来的三个字节就是&ldquo;7cac81&rdquo;，这三个字节是所在主机的唯一标识符，一般是机器主机名的散列值，这样就确保了不同主机生成不同的机器hash值，确保在分布式中不造成冲突，这也就是在同一台机器生成的objectId中间的字符串都是一模一样的原因。<o:p></o:p></p><p class="MsoNormal" style="margin-left: 39.0pt; text-indent: -18.0pt; mso-list: l2 level1 lfo3; layout-grid-mode: char; mso-layout-grid-align: none;"><!--[if !supportLists]-->3) <!--[endif]-->PID<o:p></o:p></p><p class="MsoNormal" style="text-indent: 21.0pt; layout-grid-mode: char; mso-layout-grid-align: none;">进程ID。上面的Machine是为了确保在不同机器产生的objectId不冲突，而pid就是为了在同一台机器不同的mongodb进程产生了objectId不冲突，接下来的&ldquo;af71&rdquo;两位就是产生objectId的进程标识符。</p><p class="MsoNormal" style="margin-left: 39.0pt; text-indent: -18.0pt; mso-list: l2 level1 lfo3; layout-grid-mode: char; mso-layout-grid-align: none;"><!--[if !supportLists]-->4) <!--[endif]-->INC<o:p></o:p></p><p class="MsoNormal" style="text-indent: 21.0pt; layout-grid-mode: char; mso-layout-grid-align: none;">自增计数器。前面的九个字节是保证了一秒内不同机器不同进程生成objectId不冲突，这后面的三个字节&ldquo;36236b&rdquo;是一个自动增加的计数器，用来确保在同一秒内产生的objectId也不会发现冲突，允许256的3次方等于16777216条记录的唯一性。<o:p></o:p></p><p class="MsoNormal" style="text-indent: 21.0pt; layout-grid-mode: char; mso-layout-grid-align: none;">总的来看，objectId的前4个字节时间戳，记录了文档创建的时间；接下来3个字节代表了所在主机的唯一标识符，确定了不同主机间产生不同的objectId；后2个字节的进程id，决定了在同一台机器下，不同mongodb进程产生不同的objectId；最后通过3个字节的自增计数器，确保同一秒内产生objectId的唯一性。ObjectId的这个主键生成策略，很好地解决了在分布式环境下高并发情况主键唯一性问题，值得学习借鉴。</p><h1 style="margin-top: 7.8pt; margin-right: 0cm; margin-bottom: 7.8pt; margin-left: 43.8pt; mso-para-margin-top: .5gd; mso-para-margin-right: 0cm; mso-para-margin-bottom: .5gd; mso-para-margin-left: 43.8pt; text-align: justify; text-justify: inter-ideograph; text-indent: -43.8pt; mso-char-indent-count: -3.13; line-height: normal; mso-list: l1 level1 lfo1; layout-grid-mode: char; mso-layout-grid-align: none;"><!--[if !supportLists]-->二、 <!--[endif]-->源码分析<o:p></o:p><p class="MsoNormal" style="text-indent: 21.0pt; mso-outline-level: 1; layout-grid-mode: char; mso-layout-grid-align: none;">MongoDB可以通过自身的服务来产生objectId，也可以通过客户端的驱动程序来生成objectId。虽然objectId是轻量级的，但如果全部在服务端生成肯定会花费一点开销。所以，能从服务器端转移到客户端驱动程序完成的，就尽量转移到客户端来完成，减少服务器端的开销。我们来看一下，客户端的驱动程序是如何来生成objectId的。<o:p></o:p></p><p class="MsoNormal" style="margin-left: 57.0pt; text-indent: -36.0pt; mso-outline-level: 1; mso-list: l4 level1 lfo5; layout-grid-mode: char; mso-layout-grid-align: none;"><!--[if !supportLists]-->1、下载mongodb java driver源码。(https://github.com/mongodb/mongo-java-driver/downloads)</p><p class="MsoNormal" style="margin-left: 57.0pt; text-indent: -36.0pt; mso-outline-level: 1; mso-list: l4 level1 lfo5; layout-grid-mode: char; mso-layout-grid-align: none;"><!--[if !supportLists]-->2、分析ObjectId.java<o:p></o:p></p><p class="MsoNormal" style="text-indent: 21.0pt; mso-char-indent-count: 2.0; mso-outline-level: 1; layout-grid-mode: char; mso-layout-grid-align: none;">驱动源码的org.bson包下找到ObjectId.java，进行分析。默认构建的objectId代码如下代码所示，objectId主要由_time，_machine和_inc组成。</p><p class="MsoNormal" style="text-indent: 21.0pt; mso-char-indent-count: 2.0; mso-outline-level: 1; layout-grid-mode: char; mso-layout-grid-align: none;"></p>构建objectId <pre> 1 public class ObjectId implements Comparable&lt;ObjectId&gt; , java.io.Serializable { 2 final int _time; 3     final int _machine; 4     final int _inc; 5 boolean _new; 6  7 public ObjectId(){ 8         _time = (int) (System.currentTimeMillis() / 1000); 9         _machine = _genmachine;10         _inc = _nextInc.getAndIncrement();11         _new = true;12 }13 &hellip;&hellip;14 }</pre>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>