---
layout: post
title: [翻译]JavaScript秘密花园 - Object, Prototype
---

<header><section><header><h1 id="intro">简介（Intro）</header><p>JavaScript秘密花园是一个不断更新的文档，主要关心JavaScript一些古怪用法。对于如何避免常见的错误，难以发现的问题，以及性能问题和不好的实践给出建议，初学者可以籍此深入了解JavaScript的语言特性。</p><p>JavaScript秘密花园不是用来教你JavaScript。为了更好的理解这篇文章的内容，你需要事先学习JavaScript的基础知识。在Mozilla开发者网络中有一系列非常棒的JavaScript学习向导。</p></section><section><header>关于作者（The authors）</header><p>这篇文章的作者是两位Stack Overflow的用户, Ivo Wetzel(写作) 和 Zhang Yi Jiang (设计)。</p></section><section><header>贡献者（Contributors）</header>Caio Rom?o (拼写检查)Andreas Blixt (语言修正)</section><section><header>许可（License）</header><p>JavaScript花园在MIT license许可协议下发布，并存放在开源社区GitHub。如果你发现错误或者打字错误，请file an issue或者pull request。你也可以在Stack Overflow的聊天室JavaScript room找到我们。</p></section><section><header>中文翻译（Chinese Translation）</header>JavaScript Garden - 原文JavaScript Garden - 中文翻译译作者：三生石上<p>本中文翻译由三上石上原创，博客园首发，转载请注明出处。</p></section></article>            </header><section><header><h2 id="objects">对象（Objects） #top</header><p>JavaScript中所有变量都是对象，除了两个例外<code>null</code> 和 <code>undefined</code>。</p><pre class="brush:js;"><code>false.toString() // 'false'[1, 2, 3].toString(); // '1,2,3'function Foo(){}Foo.bar = 1;Foo.bar; // 1</code></pre><p>一个常见的误解是数字的字面值（literal）不是对象。这是因为JavaScript解析器的一个错误，它试图将<em>点操作符</em>解析为浮点数字面值的一部分。</p><pre class="brush:js;"><code>2.toString(); // 出错：SyntaxError</code></pre><p>有很多变通方法可以让数字的字面值看起来像对象。</p><pre class="brush:js;"><code>2..toString(); // 第二个点号可以正常解析2 .toString(); // 注意点号前面的空格(2).toString(); // 2先被计算</code></pre></section><section><header>对象作为数据类型（Objects as a data type）</header><p>JavaScript的对象可以作为<em>哈希表</em>使用，主要用来保存命名的键与值的对应关系。</p><p>使用对象的字面语法 - <code>{}</code> - 可以创建一个简单对象。这个新创建的对象从<code>Object.prototype</code>继承下面，没有任何自定义属性。</p><pre class="brush:js;"><code>var foo = {}; // 一个空对象// 一个新对象，拥有一个值为12的自定义属性'test'var bar = {test: 12};</code></pre></section><section><header>访问属性（Accessing properties）</header><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。</p><pre class="brush:js;"><code>var foo = {name: 'Kitten'}foo.name; // kittenfoo['name']; // kittenvar get = 'name';foo[get]; // kittenfoo.1234; // SyntaxErrorfoo['1234']; // works</code></pre><p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效 - 动态设置属性 - 属性名不是一个有效的变量名（译者注：比如属性名中包含空格，或者属性名是JS的关键词）（译者注：在JSLint语法检测工具中，点操作符是推荐做法）</p></section><section><header>删除属性（Deleting properties）</header><p>删除属性的唯一方法是使用<code>delete</code>操作符；设置属性为<code>undefined</code>或者<code>null</code>并不能真正的删除属性，而仅仅是移除了属性和值的关联。</p><pre class="brush:js;"><code>var obj = {    bar: 1,    foo: 2,    baz: 3};obj.bar = undefined;obj.foo = null;delete obj.baz;for(var i in obj) {    if (obj.hasOwnProperty(i)) {        console.log(i, '' + obj[i]);    }}</code></pre><p>上面的输出结果有<code>bar undefined</code>和<code>foo null</code> - 只有<code>baz</code>被真正的删除了，所以从输出结果中消失。</p></section><section><header>属性名的语法（Notation of keys）</header><pre class="brush:js;"><code>var test = {    'case': 'I am a keyword so I must be notated as a string',    delete: 'I am a keyword too so me' // 出错：SyntaxError};</code></pre><p>对象的属性名可以使用字符串或者普通字符声明。但是由于JavaScript解析器的另一个错误设计，上面的第二种声明方式在ECMAScript 5之前会抛出<code>SyntaxError</code>的错误。</p><p>这个错误的原因是<code>delete</code>是JavaScript语言的一个<em>关键词</em>；因此为了在更低版本的JavaScript引擎下也能正常运行，必须使用<em>字符串字面值</em>声明方式。</p></section></article><section><header><h2 id="prototype">原型（The prototype） #top</header><p>JavaScript不包含传统的类继承模型，而是使用<em>prototypical</em>原型模型。</p><p>虽然这经常被当作是JavaScript的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。实现传统的类继承模型是很简单，但是实现JavaScript中的原型继承则要困难的多。（It is for example fairly trivial to build a classic model on top of it, while theother way around is a far more difficult task.）</p><p>由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p><p>第一个不同之处在于JavaScript使用<em>原型链</em>的继承方式。</p><p>注意: 简单的使用<code>Bar.prototype = Foo.prototype</code>将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。</p></aside><pre class="brush:js;"><code>function Foo() {    this.value = 42;}Foo.prototype = {    method: function() {}};function Bar() {}// 设置Bar的prototype属性为Foo的实例对象Bar.prototype = new Foo();Bar.prototype.foo = 'Hello World';// 修正Bar.prototype.constructor为Bar本身Bar.prototype.constructor = Bar;var test = new Bar() // 创建Bar的一个新实例// 原型链test [Bar的实例]    Bar.prototype [Foo的实例]         { foo: 'Hello World' }        Foo.prototype            {method: ...};            Object.prototype                {toString: ... /* etc. */};</code></pre><p>上面的例子中，<code>test</code>对象从<code>Bar.prototype</code>和<code>Foo.prototype</code>继承下来；因此，它能否访问<code>Foo</code>的原型方法<code>method</code>。但是它不能访问<code>Foo</code>的实例属性<code>value</code>，因为这个属性在<code>Foo</code>的构造函数中定义。（But it will not have access to the property <code>value</code> of a <code>Foo</code> instance, since that property gets defined in the constructorof <code>Foo</code>. But this constructor has to be called explicitly.）</p><p>（译者注：我认为这个描述是错误的，test.value是可以访问的。因为在设置Bar.prototype = new Foo();时，<code>value</code>也就成为Bar.prototype上的一个属性。如果你有不同观点，可以到我的博客评论。）</p><p>注意: 不要使用<code>Bar.prototype = Foo</code>，因为这不会执行<code>Foo</code>的原型，而是指向函数<code>Foo</code>。因此原型链将会回溯到<code>Function.prototype</code>而不是<code>Foo.prototype</code>，因此<code>method</code>将不会在Bar的原型链上。</p></aside></section><section><header>属性查找（Property lookup）</header><p>当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。</p><p>到查找到达原型链的顶部 - 也就是<code>Object.prototype</code> - 但是仍然没有找到指定的属性，就会返回undefined。</p></section><section><header>原型属性（The prototype property）</header><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它（prototype）。然而将原子类型赋给prototype的操作将会被忽略。</p><pre class="brush:js;"><code>function Foo() {}Foo.prototype = 1; // no effect</code></pre><p>而将对象赋值给prototype，正如上面的例子所示，将会动态的创建原型链。</p></section><section><header>性能（Performance）</header><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。</p><p>并且，当使用for-in循环遍历对象的属性时，原型链上的所有属性都将被访问。</p></section><section><header>扩展内置类型的原型（Extension of native prototypes）</header><p>一个错误特性被经常使用，那就是扩展<code>Object.prototype</code>或者其他内置类型的原型对象。</p><p>这种技术被称之为monkey patching并且会破坏<em>封装</em>。虽然它被广泛的应用到一些JS类库中比如Prototype,但是我仍然不认为为内置类型添加一些<em>非标准</em>的函数是个好主意。</p><p>扩展内置类型的唯一理由是为了和新的JavaScript保持一致，比如<code>Array.forEach</code>。（译者注：这是编程领域常用的一种方式，称之为Backport，也就是将新的补丁添加到老版本中。）The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines; for example, <code>Array.forEach</code>.</p></section><section><header>总结（In conclusion）</header><p>在写复杂的JavaScript应用之前，充分理解原型链继承的工作方式是每个JavaScript程序员必修的功课。要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。更进一步，绝对不要扩展内置类型的原型，除非是为了和新的JavaScript引擎兼容。</p></section></article><p>本中文翻译由三上石上原创，博客园首发，转载请注明出处。</p>JavaScript Garden - 中文翻译

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>