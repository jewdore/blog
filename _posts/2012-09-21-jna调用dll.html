---
layout: post
title: JNA调用DLL
---

<p>介绍给大家介绍一个最新的访问本机代码的Java框架&#8212;JNA。</p><p>JNA(Java Native Access)框架是一个开源的Java框架，是SUN公司主导开发的，建立在经典的JNI的基础之上的一个框架。</p><p>JNA项目地址：https://jna.dev.java.net/</p><p>非常强大、易用，功能上类似与.NET的P/Invoke。</p><p>不堪回首的JNI我们知道，使用JNI调用.dll/.so共享类库是非常非常麻烦和痛苦的。</p><p>如果有一个现有的.dll/.so文件，如果使用JNI技术调用，我们首先需要另外使用C语言写一个.dll/.so共享库，使用SUN规定的数据结构替代C语言的数据结构，调用已有的 dll/so中公布的函数。</p><p>然后再在Java中载入这个适配器dll/so，再编写Java native函数作为dll中函数的代理。</p><p>经过2个繁琐的步骤才能在Java中调用本地代码。</p><p>因此，很少有Java程序员愿意编写调用dll/.so库中的原生函数的java程序。这也使Java语言在客户端上乏善可陈。可以说JNI是Java的一大弱点！</p><p>.NET平台上强大的P/Invoke而在.NET平台上，强大的P/Invoke技术使我们Java程序员非常羡慕。使用P/Invoke技术，只需要使用编写一个.NET函数，再加上一个声明的标注，就可以直接调用dll中的函数。</p><p>不需要你再使用C语言编写dll来适配。</p><p>不逊于P/Invoke的JNA现在，不需要再羡慕.NET的P/Invoke机制了。JNA把对dll/.so共享库的调用减少到了和P/Invoke相同的程度。</p><p>使用JNA，不需要再编写适配用的.dll/.so，只需要在Java中编写一个接口和一些代码，作为.dll/.so的代理，就可以在Java程序中调用dll/so。</p><p>JNA快速启动</p><p> 现在让我们直接进入JNA的世界。</p><p>你只需要下载一个jar包，就可以使用JNA的强大功能方便地调用动态链接库中的C函数。</p><p>1，下载jna.jar。</p><p>在这里http://cloud.github.com/downloads/twall/jna/jna.jar</p><p>2，现在你已经可以使用JNA了。</p><p>为了方便你参考JNA的java类库，我制作了《JNA3.09API参考手册》，是CHM格式的。你可以到这里下载 http://download.csdn.net/source/900438</p><p>JNA例子</p><p>例子1 现在让我们运行一个JNA程序，感受它的强大威力。</p><p>1，在Java项目中引入jna.jar包。</p><p>2，创建一个类：</p><p>import com.sun.jna.Library;</p><p>import com.sun.jna.Native;</p><p>import com.sun.jna.Platform;</p><p>/** Simple example of native library declaration and usage. */</p><p>public class HelloWorld {</p><p> public interface CLibrary extends Library {</p><p> CLibrary INSTANCE = (CLibrary)</p><p> Native.loadLibrary((Platform.isWindows() ? "msvcrt" : "c"),</p><p> CLibrary.class);</p><p> void printf(String format, Object... args);</p><p> }</p><p> public static void main(String[] args) {</p><p> CLibrary.INSTANCE.printf("Hello, World\n");</p><p> for (int i=0;i &lt; args.length;i++) {</p><p> CLibrary.INSTANCE.printf("Argument %d: %s\n", i, args[i]);</p><p> }</p><p> }</p><p>}</p><p>3，执行，可以看到控制台中打印出了</p><p>Hello, World</p><p> 但是，请注意，这个程序实际上是使用msvcrt.dll这个C运行时库中的printf函数打印出上面这些字符的。</p><p> 看，多简单，不需要写一行C代码，就可以直接在Java中调用外部动态链接库中的函数！</p><p>例子2 </p><p> 上面那个例子使用了操作系统自带的动态链接库，现在我们再自己写一个动态链接库试试。</p><p>1，在VS中选择C++语言，然后选择创建一个Win32程序。 选择dll类型。</p><p>2，发布的C函数是：</p><p>#define MYLIBAPI extern "C" __declspec( dllexport ) </p><p>MYLIBAPI void say(wchar_t* pValue);</p><p>这个函数的实现是：</p><p>void say(wchar_t* pValue){</p><p> std::wcout.imbue(std::locale("chs"));</p><p> std::wcout&lt;&lt;L"上帝说："&lt;&lt;pValue&lt;&lt;std::endl;</p><p>}</p><p>它需要传入一个Unicode编码的字符数组。然后在控制台上打印出一段中文字符。</p><p>3，生成dll。然后把生成的dll文件复制到Eclipse项目中，放在项目下面。</p><p>4，在Eclipse中编写以下代码：</p><p>import com.sun.jna.Library;</p><p>import com.sun.jna.Native;</p><p>import com.sun.jna.WString;</p><p>/**</p><p>* @author 沈东良 Edward Shen shendl_s@hotmail.com</p><p>* 2008-11-23 下午05:07:14</p><p>*TestDll1.dll</p><p>*/</p><p>public class TestDll1Service {</p><p> public interface TestDll1 extends Library {</p><p> /**</p><p> * 当前路径是在项目下，而不是bin输出目录下。</p><p> */</p><p> TestDll1 INSTANCE = (TestDll1)Native.loadLibrary("TestDll1", TestDll1.class);</p><p> public void say(WString value);</p><p> }</p><p> /**</p><p> *</p><p> */</p><p> public TestDll1Service() {</p><p> // TODO Auto-generated constructor stub</p><p> }</p><p> /**</p><p> * @param args</p><p> */</p><p> public static void main(String[] args) {</p><p> // TODO Auto-generated method stub</p><p> TestDll1.INSTANCE.say(new WString("Hello World!"));</p><p> System.out.println("HHEEH我我们无法万恶");</p><p> }</p><p>}</p><p>5，执行这个Java类。可以看到控制台下如下输出：</p><p>上帝说：Hello World!</p><p>HHEEH我我们无法万恶</p><p>6，上面一行是C语言使用C++的std::wcout输出的。</p><p>下面一行是Java语言输出的。</p><p>DLL位置：</p><p>方式一：把所有动态库拷贝到system32目录方式二：String path = ESAMServer.class.getResource("/").getPath()+"/dll";</p><p>System.load(path+"/MyNative.dll");NativeLibrary.addSearchPath("MyNative.dll", path);</p><p>JNA技术解密JNA工作原理JNA是建立在JNI技术基础之上的一个Java类库，它使您可以方便地使用java直接访问动态链接库中的函数。</p><p>原来使用JNI，你必须手工用C写一个动态链接库，在C语言中映射Java的数据类型。</p><p>JNA中，它提供了一个动态的C语言编写的转发器，可以自动实现Java和C的数据类型映射。你不再需要编写C动态链接库。</p><p>当然，这也意味着，使用JNA技术比使用JNI技术调用动态链接库会有些微的性能损失。可能速度会降低几倍。但影响不大。</p><p>JNA技术难点</p><p>1，当前路径是在项目下，而不是bin输出目录下。</p><p>2，数据结构的对应关系：</p><p>Java&#8212;C和操作系统数据类型的对应表Java TypeC TypeNative Representationbooleanint32-bit integer (customizable)bytechar8-bit integercharwchar_tplatform-dependentshortshort16-bit integerintint32-bit integerlonglong long, __int6464-bit integerfloatfloat32-bit floating pointdoubledouble64-bit floating pointBufferPointer pointerplatform-dependent (32- or 64-bit pointer to memory)&lt;T&gt;[] (array of primitive type)pointerarray32- or 64-bit pointer to memory (argument/return)contiguous memory (struct member)除了上面的类型，JNA还支持常见的数据类型的映射。Stringchar*NUL-terminated array (native encoding or jna.encoding)WStringwchar_t*NUL-terminated array (unicode)String[]char**NULL-terminated array of C stringsWString[]wchar_t**NULL-terminated array of wide C stringsStructurestruct*structpointer to struct (argument or return) (or explicitly)struct by value (member of struct) (or explicitly)Unionunionsame as StructureStructure[]struct[]array of structs, contiguous in memoryCallback&lt;T&gt; (*fp)()function pointer (Java or native)NativeMappedvariesdepends on definitionNativeLonglongplatform-dependent (32- or 64-bit integer)PointerTypepointersame as Pointer</p><p>JNA编程过程</p><p>JNA把一个dll/.so文件看做是一个Java接口。</p><p>Dll是C函数的集合、容器，这正和接口的概念吻合。</p><p> 我们定义这样一个接口，</p><p>public interface TestDll1 extends Library {</p><p> /**</p><p> * 当前路径是在项目下，而不是bin输出目录下。</p><p> */</p><p> TestDll1 INSTANCE = (TestDll1)Native.loadLibrary("TestDll1", TestDll1.class);</p><p> public void say(WString value);</p><p> }</p><p>如果dll是以stdcall方式输出函数，那么就继承StdCallLibrary。否则就继承默认的Library接口。</p><p>接口内部需要一个公共静态常量：instance。</p><p>TestDll1 INSTANCE = (TestDll1)Native.loadLibrary("TestDll1", TestDll1.class);</p><p>通过这个常量，就可以获得这个接口的实例，从而使用接口的方法。也就是调用外部dll的函数！</p><p>注意：</p><p>1，Native.loadLibrary()函数有2个参数：</p><p> 1，dll或者.so文件的名字，但不带后缀名。这符合JNI的规范，因为带了后缀名就不可以跨操作系统平台了。</p><p>搜索dll的路径是：</p><p>1）项目的根路径</p><p>2）操作系统的全局路径、</p><p>3）path指定的路径。</p><p>2，第二个参数是本接口的Class类型。</p><p>JNA通过这个Class类型，根据指定的dll/.so文件，动态创建接口的实例。</p><p>2，接口中你只需要定义你需要的函数或者公共变量，不需要的可以不定义。</p><p>public void say(WString value);</p><p>参数和返回值的类型，应该和dll中的C函数的类型一致。</p><p>这是JNA，甚至所有跨平台调用的难点。</p><p>这里，C语言的函数参数是：wchar_t*。</p><p>JNA中对应的Java类型是WStirng。</p><p>所有跨平台、跨语言调用的难点有过跨语言、跨平台开发的程序员都知道，跨平台、语言调用的难点，就是不同语言之间数据类型不一致造成的问题。绝大部分跨平台调用的失败，都是这个问题造成的。</p><p>关于这一点，不论何种语言，何种技术方案，都无法解决这个问题。</p><p>这需要程序员的仔细开发和设计。这是程序员的责任。</p><p>常见的跨平台调用有：1，Java调用C语言编写的dll、.so动态链接库中的函数。</p><p>2，.NET通过P/Invoke调用C语言编写的dll、.so动态链接库中的函数。</p><p>3，通过WEBService，在C,C++,Java,.NET等种种语言间调用。</p><p> WebService传递的是xml格式的数据。</p><p>即使是强大的P/Invoke或者WebService，在遇到复杂的数据类型和大数据量的传递时，还是会碰到很大的困难。</p><p>因为，一种语言的复杂的数据类型，很难用另一种语言来表示。这就是跨平台调用问题的本质。如，WEBService调用中，很多语言，如Java，.NET都有自动实现的Java/.NET类型和XML类型之间的映射的类库或者工具。</p><p>但是，在现实的编程环境中，如果类型非常复杂，那么这些自动转换工具常常力不从心。</p><p>要么Object-XML映射错误。</p><p>要么映射掉大量的内存。</p><p>因此，我个人对这些Object-XML映射框架相当不感冒。</p><p>我现在使用WEBService，都是直接手工使用xml处理工具提取xml中的数据构建对象。或者反过来，手工根据Object中的属性值构建xml数据。</p><p>Java和C语言之间的调用问题，也是如此。</p><p>Java要调用C语言的函数，那么就必须严格按照C语言要求的内存数量提供Java格式的数据。要用Java的数据类型完美模拟C语言的数据类型。</p><p>JNA已经提供了大量的类型匹配C语言的数据类型。</p><p>跨平台、跨语言调用的第一原则：就是尽量使用基本、简单的数据类型，尽量少跨语言、平台传递数据！只有你才能拯救你自己。</p><p>如果在你的程序中，有复杂的数据类型和庞大的跨平台数据传递。那么你必须另外写一些Fa&#231;ade接口，把需要传递的数据类型简化，把需要传递的数据量简化。</p><p>否则，不论是实现的难度还是程序的性能都很难提高。</p><p>JNI还是不能废我们已经见识了JNA的强大。JNI和它相比是多么的简陋啊！</p><p>但是，有些需求还是必须求助于JNI。</p><p>JNA是建立在JNI技术基础之上的一个框架。</p><p>使用JNI技术，不仅可以实现Java访问C函数，也可以实现C语言调用Java代码。</p><p>而JNA只能实现Java访问C函数，作为一个Java框架，自然不能实现C语言调用Java代码。此时，你还是需要使用JNI技术。</p><p>JNI是JNA的基础。是Java和C互操作的技术基础。</p><p>本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/shendl/archive/2008/12/23/3589676.aspx</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>