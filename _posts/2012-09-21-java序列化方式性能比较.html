---
layout: post
title: java序列化方式性能比较
---

<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">来源：http://john521.iteye.com/blog/1099574</p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"></p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">有一个很不错的工具http://github.com/eishay/jvm-serializers/，可以用它来评测各种流行的java序列化反序列化工具，使用上也很简单。想试试该工具的，下载源码后参考起README操作即可。而我更关心的是，是各种工具的性能对比，以作选择的一个衡量标准，也就是http://github.com/eishay/jvm-serializers/wiki的 图示和数据。本文也就简单转摘其图示，图示中的java-manual指的是根据对象（数据）&#26684;式手工操作（当然是最快的，但不具有通用性），java- buildin-in就是内置的序列化方式（ObjectOutputStream、ObjectInputStream），其他工具的使用版本可以查看 其wiki。</p><h2 style="font-size:1.5em; line-height:1.5em; margin-top:0px; margin-right:0px; margin-bottom:0.5em; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:black">1、Total Time (“total”)<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">创建一个对象，将其序列化成一个字节数组，然后再反序列化成一个对象。</p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"></p><h2 style="font-size:1.5em; line-height:1.5em; margin-top:0px; margin-right:0px; margin-bottom:0.5em; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:black">2、Serialization Time (“ser”)<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">创建一个对象，将其序列化成一个字节数组。</p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"></p><h2 style="font-size:1.5em; line-height:1.5em; margin-top:0px; margin-right:0px; margin-bottom:0.5em; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:black">3、Deserialization Time (“deser&#43;deep”)<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">相比于序列化，反序列化更耗时。为了更公平的比较，jvm-serializers在反序列化测试时访问了反序列化得到的对象的所有字段（也就是deep的含义），因为部分工具反序列化时“偷懒”而没有做足工作。</p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"></p><h2 style="font-size:1.5em; line-height:1.5em; margin-top:0px; margin-right:0px; margin-bottom:0.5em; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:black">4、Serialized Size (“size”)<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">序列化数据的大小，这个大小会依赖于使用的数据。</p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"></p><h2 style="font-size:1.5em; line-height:1.5em; margin-top:0px; margin-right:0px; margin-bottom:0.5em; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:black">5、Serialization Compressed Size (“size&#43;dfl”)<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">使用java内置的DEFLATE(zlib)压缩的序列化数据的大小。</p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px"></p><h2 style="font-size:1.5em; line-height:1.5em; margin-top:0px; margin-right:0px; margin-bottom:0.5em; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; color:black">6、Object Creation Time (“create”)<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">对象创建耗时很短（平均100纳秒）所以通常的比较没什么意义。不过，不同工具创建的对象在表现上会有不同。有的工具只是创建普通的java类，你可以直接访问其字段，而有的使用get/set方法，有的使用builder模式。</p><p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px">分析这些对比，java内置的序列化方式性能很差（这才催生了各种序列化工具）。在这些工具中，protostuff表现极为出色，盖过了名头响亮 的protobuff和thrift。通用&#26684;式中，json要比xml强不少，而不同工具对同样&#26684;式的性能表现也有差别，这也给了选择工具的一个指导。另 一个&#20540;得一提的是bson，尽管jvm-serializers没有包含它，相信性能上应该不错。也可以参考jvm-serializers已有工具评测 代码的实现，添加比如处理bson、php等&#26684;式的序列化工具的评测。</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>