---
layout: post
title: 解决Android平台移植ffmpeg的一揽子问题
---

<p>Copy from http://blog.csdn.net/moruite/archive/2011/04/06/6305944.aspx</p><p>IT行业是一个踩在巨人肩膀上前进的行业，否则做的事情不一定有意义，所以我也是基于havlenapetr移植的ffmpeg基础上做了些改进，他做的主要贡献有：</p><p>1. 移植了ffmpeg并将与媒体相关的结构体在java层重新进行了封装，方便应用程序在java层直接操作ffmpeg API,如各种媒体格式转码及播放，如图1所示</p><p>2. 模仿Android的MediaPlayer类实现了ffmpeg的播放接口，如setDataSource(),setDisplay(),start(), stop(),pause()等，缺点是没有实现seek功能。</p><p>3. 实现了一个简单播放器功能，抛弃掉ffmpeg自带的ffplay播放器，他重新实现了音视频的分离播放和同步处理等播放器应有的功能。</p><p>基于Android移植ffmpeg的意义在于：</p><p>1.解决了Android媒体框架OpenCore的多媒体支持不足，虽然说Android平台的软解功耗大，但是从PC机的发展历史看，Android的视频处理以后也会走以硬解为主，软解为辅的路线。</p><p>2. 解决Android平台直播的问题，虽然Android支持RTSP/RTP的直播方案，但是这种方案主要是普遍用在电信设备上，基于互联网的海量视频服务提供者还是以http live streaming方案为主，测试时可以用ffmpeg将直播流打包成分段的ts流(如10秒钟),然后组织成m3u8文件实现完整的直播方案，而且互联网的直播内容还有很多是基于mms协议的，视频格式是wmv,要聚集这些内容都是离不开ffmpeg软解的。</p><p>IT行业是一个踩在巨人肩膀上前进的行业，否则做的事情不一定有意义，所以我也是基于havlenapetr移植的ffmpeg基础上做了些改进，他做的主要贡献有：</p><p>1. 移植了ffmpeg并将与媒体相关的结构体在java层重新进行了封装，方便应用程序在java层直接操作ffmpeg API,如各种媒体格式转码及播放，如图1所示</p><p>2. 模仿Android的MediaPlayer类实现了ffmpeg的播放接口，如setDataSource(),setDisplay(),start(), stop(),pause()等，缺点是没有实现seek功能。</p><p>3. 实现了一个简单播放器功能，抛弃掉ffmpeg自带的ffplay播放器，他重新实现了音视频的分离播放和同步处理等播放器应有的功能。</p><p>图1 ffmpeg的java层封装</p><p>基于Android移植ffmpeg的意义在于：</p><p>1.解决了Android媒体框架OpenCore的多媒体支持不足，虽然说Android平台的软解功耗大，但是从PC机的发展历史看，Android的视频处理以后也会走以硬解为主，软解为辅的路线。</p><p>2. 解决Android平台直播的问题，虽然Android支持RTSP/RTP的直播方案，但是这种方案主要是普遍用在电信设备上，基于互联网的海量视频服务提供者还是以http live streaming方案为主，测试时可以用ffmpeg将直播流打包成分段的ts流(如10秒钟),然后组织成m3u8文件实现完整的直播方案，而且互联网的直播内容还有很多是基于mms协议的，视频格式是wmv,要聚集这些内容都是离不开ffmpeg软解的。</p><p>移植步骤：</p><p>1. 下载havlenaptr移植的ffmpeg(https://github.com/havlenapetr/FFMpeg/zipball/debug).</p><p>2. 基于ndk编译下载的ffmpeg,出现的编译问题主要是文件的存放路径不对，修改jni目录下的Android.mk文件，增加头文件目录$(LOCAL_PATH)/../include/android，修改Vector.h文件为：</p><p>#include &lt;cutils/log.h&gt;#include &lt;utils/VectorImpl.h&gt;#include &lt;utils/TypeHelpers.h&gt;</p><p>3.utils目录下缺少TypeHelpers.h，添加该文件：</p><pre class="brush:cpp;gutter:true;">/* *  TypeHelpers.h *   *  Copyright 2005 The Android Open Source Project * */#ifndef ANDROID_TYPE_HELPERS_H#define ANDROID_TYPE_HELPERS_H#include &lt;new&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// ---------------------------------------------------------------------------namespace android {/* * Types traits */    template &lt;typename T&gt; struct trait_trivial_ctor  { enum { value = false }; };template &lt;typename T&gt; struct trait_trivial_dtor  { enum { value = false }; };template &lt;typename T&gt; struct trait_trivial_copy  { enum { value = false }; };template &lt;typename T&gt; struct trait_trivial_assign{ enum { value = false }; };template &lt;typename T&gt; struct trait_pointer     { enum { value = false }; };    template &lt;typename T&gt; struct trait_pointer&lt;T*&gt; { enum { value = true }; };#define ANDROID_BASIC_TYPES_TRAITS( T )                                       \    template&lt;&gt; struct trait_trivial_ctor&lt; T &gt;  { enum { value = true }; };    \    template&lt;&gt; struct trait_trivial_dtor&lt; T &gt;  { enum { value = true }; };    \    template&lt;&gt; struct trait_trivial_copy&lt; T &gt;  { enum { value = true }; };    \    template&lt;&gt; struct trait_trivial_assign&lt; T &gt;{ enum { value = true }; }; #define ANDROID_TYPE_TRAITS( T, ctor, dtor, copy, assign )                    \    template&lt;&gt; struct trait_trivial_ctor&lt; T &gt;  { enum { value = ctor }; };    \    template&lt;&gt; struct trait_trivial_dtor&lt; T &gt;  { enum { value = dtor }; };    \    template&lt;&gt; struct trait_trivial_copy&lt; T &gt;  { enum { value = copy }; };    \    template&lt;&gt; struct trait_trivial_assign&lt; T &gt;{ enum { value = assign }; }; template &lt;typename TYPE&gt;struct traits {    enum {        is_pointer          = trait_pointer&lt;TYPE&gt;::value,        has_trivial_ctor    = is_pointer || trait_trivial_ctor&lt;TYPE&gt;::value,        has_trivial_dtor    = is_pointer || trait_trivial_dtor&lt;TYPE&gt;::value,        has_trivial_copy    = is_pointer || trait_trivial_copy&lt;TYPE&gt;::value,        has_trivial_assign  = is_pointer || trait_trivial_assign&lt;TYPE&gt;::value       };};template &lt;typename T, typename U&gt;struct aggregate_traits {    enum {        is_pointer          = false,        has_trivial_ctor    = traits&lt;T&gt;::has_trivial_ctor &amp;&amp; traits&lt;U&gt;::has_trivial_ctor,        has_trivial_dtor    = traits&lt;T&gt;::has_trivial_dtor &amp;&amp; traits&lt;U&gt;::has_trivial_dtor,        has_trivial_copy    = traits&lt;T&gt;::has_trivial_copy &amp;&amp; traits&lt;U&gt;::has_trivial_copy,        has_trivial_assign  = traits&lt;T&gt;::has_trivial_assign &amp;&amp; traits&lt;U&gt;::has_trivial_assign    };};// ---------------------------------------------------------------------------/* * basic types traits */ ANDROID_BASIC_TYPES_TRAITS( void );ANDROID_BASIC_TYPES_TRAITS( bool );ANDROID_BASIC_TYPES_TRAITS( char );ANDROID_BASIC_TYPES_TRAITS( unsigned char );ANDROID_BASIC_TYPES_TRAITS( short );ANDROID_BASIC_TYPES_TRAITS( unsigned short );ANDROID_BASIC_TYPES_TRAITS( int );ANDROID_BASIC_TYPES_TRAITS( unsigned int );ANDROID_BASIC_TYPES_TRAITS( long );ANDROID_BASIC_TYPES_TRAITS( unsigned long );ANDROID_BASIC_TYPES_TRAITS( long long );ANDROID_BASIC_TYPES_TRAITS( unsigned long long );ANDROID_BASIC_TYPES_TRAITS( float );ANDROID_BASIC_TYPES_TRAITS( double );// ---------------------------------------------------------------------------    /* * compare and order types */template&lt;typename TYPE&gt; inlineint strictly_order_type(const TYPE&amp; lhs, const TYPE&amp; rhs) {    return (lhs &lt; rhs) ? 1 : 0;}template&lt;typename TYPE&gt; inlineint compare_type(const TYPE&amp; lhs, const TYPE&amp; rhs) {    return strictly_order_type(rhs, lhs) - strictly_order_type(lhs, rhs);}/* * create, destroy, copy and assign types... */ template&lt;typename TYPE&gt; inlinevoid construct_type(TYPE* p, size_t n) {    if (!traits&lt;TYPE&gt;::has_trivial_ctor) {        while (n--) {            new(p++) TYPE;        }    }}template&lt;typename TYPE&gt; inlinevoid destroy_type(TYPE* p, size_t n) {    if (!traits&lt;TYPE&gt;::has_trivial_dtor) {        while (n--) {            p-&gt;~TYPE();            p++;        }    }}template&lt;typename TYPE&gt; inlinevoid copy_type(TYPE* d, const TYPE* s, size_t n) {    if (!traits&lt;TYPE&gt;::has_trivial_copy) {        while (n--) {            new(d) TYPE(*s);            d++, s++;        }    } else {        memcpy(d,s,n*sizeof(TYPE));    }}template&lt;typename TYPE&gt; inlinevoid assign_type(TYPE* d, const TYPE* s, size_t n) {    if (!traits&lt;TYPE&gt;::has_trivial_assign) {        while (n--) {            *d++ = *s++;        }    } else {        memcpy(d,s,n*sizeof(TYPE));    }}template&lt;typename TYPE&gt; inlinevoid splat_type(TYPE* where, const TYPE* what, size_t n) {    if (!traits&lt;TYPE&gt;::has_trivial_copy) {        while (n--) {            new(where) TYPE(*what);            where++;        }    } else {         while (n--) {             *where++ = *what;        }    }}template&lt;typename TYPE&gt; inlinevoid move_forward_type(TYPE* d, const TYPE* s, size_t n = 1) {    if (!traits&lt;TYPE&gt;::has_trivial_copy || !traits&lt;TYPE&gt;::has_trivial_dtor) {        d += n;        s += n;        while (n--) {            --d, --s;            if (!traits&lt;TYPE&gt;::has_trivial_copy) {                new(d) TYPE(*s);            } else {                *d = *s;            }            if (!traits&lt;TYPE&gt;::has_trivial_dtor) {                s-&gt;~TYPE();            }        }    } else {        memmove(d,s,n*sizeof(TYPE));    }}template&lt;typename TYPE&gt; inlinevoid move_backward_type(TYPE* d, const TYPE* s, size_t n = 1) {    if (!traits&lt;TYPE&gt;::has_trivial_copy || !traits&lt;TYPE&gt;::has_trivial_dtor) {        while (n--) {            if (!traits&lt;TYPE&gt;::has_trivial_copy) {                new(d) TYPE(*s);            } else {                *d = *s;            }            if (!traits&lt;TYPE&gt;::has_trivial_dtor) {                s-&gt;~TYPE();            }            d++, s++;        }    } else {        memmove(d,s,n*sizeof(TYPE));    }}// ---------------------------------------------------------------------------/* * a key/value pair */template &lt;typename KEY, typename VALUE&gt;struct key_value_pair_t {    KEY     key;    VALUE   value;    key_value_pair_t() { }    key_value_pair_t(const key_value_pair_t&amp; o) : key(o.key), value(o.value) { }    key_value_pair_t(const KEY&amp; k, const VALUE&amp; v) : key(k), value(v)  { }    key_value_pair_t(const KEY&amp; k) : key(k) { }    inline bool operator &lt; (const key_value_pair_t&amp; o) const {        return strictly_order_type(key, o.key);    }};template&lt;&gt;template &lt;typename K, typename V&gt;struct trait_trivial_ctor&lt; key_value_pair_t&lt;K, V&gt; &gt;{ enum { value = aggregate_traits&lt;K,V&gt;::has_trivial_ctor }; };template&lt;&gt; template &lt;typename K, typename V&gt;struct trait_trivial_dtor&lt; key_value_pair_t&lt;K, V&gt; &gt;{ enum { value = aggregate_traits&lt;K,V&gt;::has_trivial_dtor }; };template&lt;&gt; template &lt;typename K, typename V&gt;struct trait_trivial_copy&lt; key_value_pair_t&lt;K, V&gt; &gt;{ enum { value = aggregate_traits&lt;K,V&gt;::has_trivial_copy }; };template&lt;&gt; template &lt;typename K, typename V&gt;struct trait_trivial_assign&lt; key_value_pair_t&lt;K, V&gt; &gt;{ enum { value = aggregate_traits&lt;K,V&gt;::has_trivial_assign};};// ---------------------------------------------------------------------------}; // namespace android// ---------------------------------------------------------------------------#endif // ANDROID_TYPE_HELPERS_H</pre>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>