---
layout: post
title: NoSQL for MySQL [HandlerSocket] 之安装与使用
---

<p>喜欢Mysql，不仅仅是因为他简单的使用，更深一层次的是因为他的开源、他的插入式引擎及更优秀的plugin！从队列式存储引擎Q4M(http://q4m.github.com/)到memcache 的UDF(http://hi.baidu.com/ytjwt/blog/item/5fc8303f226c542f71cf6c3c.html) 到本文要说到的NoSQL for MySQL，去年的某一天，一朋友跟我说，nosql性能有多好多好时，我说，如果提取像k/v形式的数据，假设：用主键查询一个数据，你觉得性能会怎样呢？其实当时我也知道，肯定是比不过memcache之类的cache，因为，mysql有一系列的认证，一系列的语法、词法分析！</p><p>前段一个偶然的时间里，下载percona-server突然发现一个名叫HandlerSocket的东东，一时好奇，google一把，发现这不就是我一直想要的在mysql里实现nosql的东西吗?兴奋之余，也动手安装及使用了一把，下面把我的步骤列出来!</p><p>主要参考：http://whitesock.javaeye.com/blog/811339</p><p>1：安装</p><p>HandlerSocket老简单了，只需要5.1版本以上的source 安装版本跟二进制版本，因为5.5GA了，所以我选择了5.5.8版本安装</p><p> 安装HandlerSocket</p><p> $ ./autogen.sh $ ./configure --with-mysql-source=../mysql-5.5.8/ --with-mysql-bindir=/usr/local/mysql55/bin/ --with-mysql-plugindir=/usr/local/mysql55/lib/plugin/</p><p> $ make $ make install</p><p>2：配置</p><p>在正式使用前，我们必须在mysql配置文件添加如下配置</p><p> [mysqld] loose_handlersocket_port = 9998 # the port number to bind to (for read requests) loose_handlersocket_port_wr = 9999 # the port number to bind to (for write requests) loose_handlersocket_threads = 16 # the number of worker threads (for read requests) loose_handlersocket_threads_wr = 1 # the number of worker threads (for write requests) open_files_limit = 65535 # to allow handlersocket accept many concurrent connections, make open_files_limit as large as possible.</p><p>重启mysql后，登录mysql，执行</p><p>install plugin handlersocket soname 'handlersocket.so';</p><p>这个时候，我们就能看到两个新端口了</p><p>netstat -lnp|grep 999tcp 0 0 0.0.0.0:9998 0.0.0.0:* LISTEN 32010/mysqld tcp 0 0 0.0.0.0:9999 0.0.0.0:* LISTEN 32010/mysqld </p><p>mysql&gt; show plugins;</p><p>| handlersocket | ACTIVE | DAEMON | handlersocket.so | BSD |+-----------------------+----------+--------------------+------------------+---------+21 rows in set (0.00 sec)</p><p>mysql&gt; show processlist;+----+-------------+-----------------+---------------+---------+------+-------------------------------------------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+-------------+-----------------+---------------+---------+------+-------------------------------------------+------------------+| 2 | system user | connecting host | NULL | Connect | NULL | handlersocket: mode=rd, 0 conns, 0 active | NULL || 3 | system user | connecting host | NULL | Connect | NULL | handlersocket: mode=rd, 0 conns, 0 active | NULL </p><p>这样就说明已经正常使用了！</p><p>3：使用</p><p>我使用perl对handlersocket进行测试使用，表也用网上的表（^-^方便）</p><p>CREATE TABLE `user` ( `user_id` int(10) unsigned NOT NULL, `user_name` varchar(50) DEFAULT NULL, `user_email` varchar(255) DEFAULT NULL, `created` datetime DEFAULT NULL, PRIMARY KEY (`user_id`), KEY `INDEX_01` (`user_name`)) ENGINE=InnoDB;</p><p>手动insert 几条语句insert into user values(4, "yangting", "D@test.com", CURRENT_TIMESTAMP); </p><p>&zwj;1）SELECT</p><p>如下我通过handlersocket对表进行查询</p><p>#!/usr/bin/perluse strict; use warnings; use Net::HandlerSocket;</p><p> #1. establishing a connection  my $args = { host =&gt; 'localhost', port =&gt; 9998 };  my $hs = new Net::HandlerSocket($args);   #2. initializing an index so that we can use in main logics.  # MySQL tables will be opened here (if not opened)  my $res = $hs-&gt;open_index(0, 'test', 'user', 'PRIMARY', 'user_name,user_email,created'); </p><p>&zwj; #这个为查询的列数，这里为三列，分别为：user_name,user_email,created die $hs-&gt;get_error() if $res != 0;  #3. main logic  #fetching rows by id  #execute_single (index id, cond, cond value, max rows, offset) </p><p>#下面这个语句的意思是：查询主键大于或等于1，总行数为2行的数据 $res = $hs-&gt;execute_single(0, '&gt;=', [ 1 ], 2, 0); </p><p>#这里我们要注意：execute_single方法的返回值类型为arrayref，其第一个元素为error code：如果为0，则为正常，否则不正常，数组从第二元素开始即为返回的值，存储格式为 后面一行紧跟前面一行！</p><p> die $hs-&gt;get_error() if $res-&gt;[0] != 0; shift(@$res);</p><p>#下面为分行打印这个数组的所有值</p><p>for (my $row = 0; $row &lt;8 ; ++$row) {  my $user_name= $res-&gt;[$row*3 + 0];  my $user_email= $res-&gt;[$row*3 + 1];  my $created= $res-&gt;[$row*3 + 2]; if ($user_name || $user_email || $created){ print "$user_name\t$user_email\t$created\n"; }else{ last; }</p><p>} #4. closing the connection  $hs-&gt;close();</p><p>&zwj;2）INSERT</p><p>&zwj;</p><p>my $args = { host =&gt; 'localhost', port =&gt; 9999 }; my $hs = new Net::HandlerSocket($args); </p><p>my $res = $hs-&gt;open_index(3, 'test', 'user', 'PRIMARY', 'user_id,user_name,user_email,created');  die $hs-&gt;get_error() if $res != 0; #INSERT $res = $hs-&gt;execute_single(3,'+', [5, 'zhongguo', 'zhogonguo@email.com','2011-01-08 13:51:33' ],1,0); die $hs-&gt;get_error() if $res-&gt;[0] != 0; $hs-&gt;close();</p><p>3）UPDATE</p><p>my $args = { host =&gt; 'localhost', port =&gt; 9999 }; my $hs = new Net::HandlerSocket($args);</p><p>&zwj;my $res = $hs-&gt;open_index(3, 'test', 'user', 'PRIMARY', 'user_name');  die $hs-&gt;get_error() if $res != 0;</p><p>#当user_id=5，更新'user_name'为woaini</p><p>$res = $hs-&gt;execute_single(3,'=', [5],1,0,'U',['woaini']); </p><p>die $hs-&gt;get_error() if $res-&gt;[0] != 0; </p><p>&zwj;$hs-&gt;close();</p><p>4) DELETE</p><p>my $args = { host =&gt; 'localhost', port =&gt; 9999 }; my $hs = new Net::HandlerSocket($args);my $res = $hs-&gt;open_index(3, 'test', 'user', 'PRIMARY', 'user_name');  die $hs-&gt;get_error() if $res != 0;</p><p>#DELETE user_id=4 的数据</p><p>$res = $hs-&gt;execute_single(3,'=', [4],1,0,'D');print $res;die $hs-&gt;get_error() if $res != 0; $hs-&gt;close();</p><p>这里我只关注了使用，对于性能，有时间，还是需要测试一把，不过，HandlerSocket作者自己就测试了</p><p>参照：http://yoshinorimatsunobu.blogspot.com/2010/10/using-mysql-as-nosql-story-for.html</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>