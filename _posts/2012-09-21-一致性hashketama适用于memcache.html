---
layout: post
title: 一致性hash, ketama, 适用于memcache
---

Richard Jones Blog <p>: http://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients <p> <p>In old way, clients mapped keys-&gt;servers like this:<pre>server = serverlist[hash(key)%serverlist.length];</pre><p>This meant that whenever we added or removed servers from the pool, everything hashed to different servers, which effectively wiped the entire cache.<p>We add (and sometimes remove) servers from the memcached pool often enough to warrant writing this - if your memcached pool never changes, you can probably stop reading now :)<p>Ketama is an implementation of a consistent hashing algorithm, meaning you can add or remove servers from the memcached pool without causing a complete remap of all keys.Here’s how it works:* Take your list of servers (eg: 1.2.3.4:11211, 5.6.7.8:11211, 9.8.7.6:11211)* Hash each server string to several (100-200) unsigned ints* Conceptually, these numbers are placed on a circle called the continuum. (imagine a clock face that goes from 0 to 2^32)* Each number links to the server it was hashed from, so servers appear at several points on the continuum, by each of the numbers they hashed to.* To map a key-&gt;server, hash your key to a single unsigned int, and find the next biggest number on the continuum. The server linked to that number is the correct server for that key.* If you hash your key to a value near 2^32 and there are no points on the continuum greater than your hash, return the first server in the continuum.If you then add or remove a server from the list, only a small proportion of keys end up mapping to different servers.<p> <p>libketama git address: https://github.com/RJ/ketama总结: ketama 适合于 memcache使用，因为部分缓存失效不是大问题，如果你使用的是TC这种全缓存的方式（缓存不能失效), 那么这个算法不适合，还需要考虑别的措施。

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>