---
layout: post
title: phpredis 官方API
---

PhpRedis<p>The phpredis extension provides an API for communicating with theRediskey-value store. It is released under thePHP License, version 3.01. This code has been developed and maintained by Owlient from November 2009 to March 2011.</p><p>You can send comments, patches, questionshere on githubor to n.favrefelix@gmail.com (@yowgi).</p>Installing/Configuring<pre>phpize./configuremake &amp;&amp; make install</pre><p><code>make install</code>copies<code>redis.so</code>to an appropriate location, but you still need to enable the module in the PHP config file. To do so, either edit your php.ini or add a redis.ini file in<code>/etc/php5/conf.d</code>with the following contents:<code>extension=redis.so</code>.</p><p>You can generate a debian package for PHP5, accessible from Apache 2 by running<code>./mkdeb-apache2.sh</code>or with<code>dpkg-buildpackage</code>or<code>svn-buildpackage</code>.</p><p>This extension exports a single class,<code>Redis</code>(and<code>RedisException</code>used in case of errors). Check outhttps://github.com/ukko/phpredis-phpdocfor a PHP stub that you can use in your IDE for code completion.</p>Install on OSX<p>If the install fails on OSX, type the following commands in your shell before trying again:</p><pre>MACOSX_DEPLOYMENT_TARGET=10.6CFLAGS="-arch i386 -arch x86_64 -g -Os -pipe -no-cpp-precomp"CCFLAGS="-arch i386 -arch x86_64 -g -Os -pipe"CXXFLAGS="-arch i386 -arch x86_64 -g -Os -pipe"LDFLAGS="-arch i386 -arch x86_64 -bind_at_load"export CFLAGS CXXFLAGS LDFLAGS CCFLAGS MACOSX_DEPLOYMENT_TARGET</pre><p>If that still fails and you are running Zend Server CE, try this right before "make":</p><pre>./configure CFLAGS="-arch i386"</pre><p>Taken fromCompiling phpredis on Zend Server CE/OSX.</p><p>See also:Install Redis &amp; PHP Extension PHPRedis with Macports.</p>Session handler (new)<p>phpredis can be used to store PHP sessions. To do this, configure<code>session.save_handler</code>and<code>session.save_path</code>in your php.ini to tell phpredis where to store the sessions:</p><pre>session.save_handler = redissession.save_path = "tcp://host1:6379?weight=1, tcp://host2:6379?weight=2&amp;timeout=2.5, tcp://host3:6379?weight=2"</pre><p><code>session.save_path</code>can have a simple<code>host:port</code>format too, but you need to provide the<code>tcp://</code>scheme if you want to use the parameters. The following parameters are available:</p>weight (integer): the weight of a host is used in comparison with the others in order to customize the session distribution on several hosts. If host A has twice the weight of host B, it will get twice the amount of sessions. In the example,<em>host1</em>stores 20% of all the sessions (1/(1+2+2)) while<em>host2</em>and<em>host3</em>each store 40% (2/1+2+2). The target host is determined once and for all at the start of the session, and doesn't change. The default weight is 1.timeout (float): the connection timeout to a redis host, expressed in seconds. If the host is unreachable in that amount of time, the session storage will be unavailable for the client. The default timeout is very high (86400 seconds).persistent (integer, should be 1 or 0): defines if a persistent connection should be used.(experimental setting)prefix (string, defaults to "PHPREDIS_SESSION:"): used as a prefix to the Redis key in which the session is stored. The key is composed of the prefix followed by the session ID.auth (string, empty by default): used to authenticate with the Redis server prior to sending commands.<p>Sessions have a lifetime expressed in seconds and stored in the INI variable "session.gc_maxlifetime". You can change it with<code>ini_set()</code>. The session handler requires a version of Redis with the<code>SETEX</code>command (at least 2.0).</p>Distributed Redis Array<p>Seededicated page.</p>Error handling<p>phpredis throws a<code>RedisException</code>object if it can't reach the Redis server. That can happen in case of connectivity issues, if the Redis service is down, or if the redis host is overloaded. In any other problematic case that does not involve an unreachable server (such as a key not existing, an invalid command, etc), phpredis will return<code>FALSE</code>.</p>MethodsRedis::__construct<em>Description</em><p>Creates a Redis client</p><em>Example</em><pre>$redis = new Redis();</pre>connect, open<em>Description</em><p>Connects to a Redis instance.</p><em>Parameters</em><p><em>host</em>: string. can be a host, or the path to a unix domain socket<em>port</em>: int, optional<em>timeout</em>: float, value in seconds (optional, default is 0 meaning unlimited)</p><em>Return Value</em><p><em>BOOL</em>:<code>TRUE</code>on success,<code>FALSE</code>on error.</p><em>Example</em><pre>$redis-&gt;connect('127.0.0.1', 6379);$redis-&gt;connect('127.0.0.1'); // port 6379 by default$redis-&gt;connect('127.0.0.1', 6379, 2.5); // 2.5 sec timeout.$redis-&gt;connect('/tmp/redis.sock'); // unix domain socket.</pre>pconnect, popen<em>Description</em><p>Connects to a Redis instance or reuse a connection already established with<code>pconnect</code>/<code>popen</code>.</p><p>The connection will not be closed on<code>close</code>or end of request until the php process ends. So be patient on to many open FD's (specially on redis server side) when using persistent connections on many servers connecting to one redis server.</p><p>Also more than one persistent connection can be made identified by either host + port + timeout or host + persistent_id or unix socket + timeout.</p><p>This feature is not available in threaded versions.<code>pconnect</code>and<code>popen</code>then working like their non persistent equivalents.</p><em>Parameters</em><p><em>host</em>: string. can be a host, or the path to a unix domain socket<em>port</em>: int, optional<em>timeout</em>: float, value in seconds (optional, default is 0 meaning unlimited)<em>persistent_id</em>: string. identity for the requested persistent connection</p><em>Return Value</em><p><em>BOOL</em>:<code>TRUE</code>on success,<code>FALSE</code>on error.</p><em>Example</em><pre>$redis-&gt;pconnect('127.0.0.1', 6379);$redis-&gt;pconnect('127.0.0.1'); // port 6379 by default - same connection like before.$redis-&gt;pconnect('127.0.0.1', 6379, 2.5); // 2.5 sec timeout and would be another connection than the two before.$redis-&gt;pconnect('127.0.0.1', 6379, 2.5, 'x'); // x is sent as persistent_id and would be another connection the the three before.$redis-&gt;pconnect('/tmp/redis.sock'); // unix domain socket - would be another connection than the four before.</pre>close<em>Description</em><p>Disconnects from the Redis instance, except when<code>pconnect</code>is used.</p>setOption<em>Description</em><p>Set client option.</p><em>Parameters</em><p><em>parameter name</em><em>parameter value</em></p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>on success,<code>FALSE</code>on error.</p><em>Example</em><pre>$redis-&gt;setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_NONE);   // don't serialize data$redis-&gt;setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);    // use built-in serialize/unserialize$redis-&gt;setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY);   // use igBinary serialize/unserialize$redis-&gt;setOption(Redis::OPT_PREFIX, 'myAppName:'); // use custom prefix on all keys</pre>getOption<em>Description</em><p>Get client option.</p><em>Parameters</em><p><em>parameter name</em></p><em>Return value</em><p>Parameter value.</p><em>Example</em><pre>$redis-&gt;getOption(Redis::OPT_SERIALIZER);   // return Redis::SERIALIZER_NONE, Redis::SERIALIZER_PHP, or Redis::SERIALIZER_IGBINARY.</pre>ping<em>Description</em><p>Check the current connection status</p><em>Parameters</em><p>(none)</p><em>Return Value</em><p><em>STRING</em>:<code>+PONG</code>on success. Throws a RedisException object on connectivity error, as described above.</p>echo<em>Description</em><p>Sends a string to Redis, which replies with the same string</p><em>Parameters</em><p><em>STRING</em>: The message to send.</p><em>Return Value</em><p><em>STRING</em>: the same message.</p>get<em>Description</em><p>Get the value related to the specified key</p><em>Parameters</em><p><em>key</em></p><em>Return Value</em><p><em>String</em>or<em>Bool</em>: If key didn't exist,<code>FALSE</code>is returned. Otherwise, the value related to this key is returned.</p><em>Examples</em><pre>$redis-&gt;get('key');</pre>setDescription<p>Set the string value in argument as value of the key.</p>Parameters<p><em>Key</em><em>Value</em><em>Timeout</em>(optional). Calling<code>SETEX</code>is preferred if you want a timeout.</p>Return value<p><em>Bool</em><code>TRUE</code>if the command is successful.</p>Examples<pre>$redis-&gt;set('key', 'value');</pre>setexDescription<p>Set the string value in argument as value of the key, with a time to live.</p>Parameters<p><em>Key</em><em>TTL</em><em>Value</em></p>Return value<p><em>Bool</em><code>TRUE</code>if the command is successful.</p>Examples<pre>$redis-&gt;setex('key', 3600, 'value'); // sets key &rarr; value, with 1h TTL.</pre>setnxDescription<p>Set the string value in argument as value of the key if the key doesn't already exist in the database.</p>Parameters<p><em>key</em><em>value</em></p>Return value<p><em>Bool</em><code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p>Examples<pre>$redis-&gt;setnx('key', 'value'); /* return TRUE */$redis-&gt;setnx('key', 'value'); /* return FALSE */</pre>del, deleteDescription<p>Remove specified keys.</p>Parameters<p>An array of keys, or an undefined number of parameters, each a key:<em>key1</em><em>key2</em><em>key3</em>...<em>keyN</em></p>Return value<p><em>Long</em>Number of keys deleted.</p>Examples<pre>$redis-&gt;set('key1', 'val1');$redis-&gt;set('key2', 'val2');$redis-&gt;set('key3', 'val3');$redis-&gt;set('key4', 'val4');$redis-&gt;delete('key1', 'key2'); /* return 2 */$redis-&gt;delete(array('key3', 'key4')); /* return 2 */</pre>multi, exec, discard.Description<p>Enter and exit transactional mode.</p>Parameters<p>(optional)<code>Redis::MULTI</code>or<code>Redis::PIPELINE</code>. Defaults to<code>Redis::MULTI</code>. A<code>Redis::MULTI</code>block of commands runs as a single transaction; a<code>Redis::PIPELINE</code>block is simply transmitted faster to the server, but without any guarantee of atomicity.<code>discard</code>cancels a transaction.</p>Return value<p><code>multi()</code>returns the Redis instance and enters multi-mode. Once in multi-mode, all subsequent method calls return the same object until<code>exec()</code>is called.</p>Example<pre>$ret = $redis-&gt;multi()    -&gt;set('key1', 'val1')    -&gt;get('key1')    -&gt;set('key2', 'val2')    -&gt;get('key2')    -&gt;exec();/*$ret == array(    0 =&gt; TRUE,    1 =&gt; 'val1',    2 =&gt; TRUE,    3 =&gt; 'val2');*/</pre>watch, unwatchDescription<p>Watches a key for modifications by another client. If the key is modified between<code>WATCH</code>and<code>EXEC</code>, the MULTI/EXEC transaction will fail (return<code>FALSE</code>).<code>unwatch</code>cancels all the watching of all keys by this client.</p>Parameters<p><em>keys</em>: a list of keys</p>Example<pre>$redis-&gt;watch('x');/* long code here during the execution of which other clients could well modify `x` */$ret = $redis-&gt;multi()    -&gt;incr('x')    -&gt;exec();/*$ret = FALSE if x has been modified between the call to WATCH and the call to EXEC.*/</pre>subscribeDescription<p>Subscribe to channels. Warning: this function will probably change in the future.</p>Parameters<p><em>channels</em>: an array of channels to subscribe to<em>callback</em>: either a string or an array($instance, 'method_name'). The callback function receives 3 parameters: the redis instance, the channel name, and the message.</p>Example<pre>function f($redis, $chan, $msg) {    switch($chan) {        case 'chan-1':            ...            break;        case 'chan-2':            ...            break;        case 'chan-2':            ...            break;    }}$redis-&gt;subscribe(array('chan-1', 'chan-2', 'chan-3'), 'f'); // subscribe to 3 chans</pre>publishDescription<p>Publish messages to channels. Warning: this function will probably change in the future.</p>Parameters<p><em>channel</em>: a channel to publish to<em>messsage</em>: string</p>Example<pre>$redis-&gt;publish('chan-1', 'hello, world!'); // send message.</pre>existsDescription<p>Verify if the specified key exists.</p>Parameters<p><em>key</em></p>Return value<p><em>BOOL</em>: If the key exists, return<code>TRUE</code>, otherwise return<code>FALSE</code>.</p>Examples<pre>$redis-&gt;set('key', 'value');$redis-&gt;exists('key'); /*  TRUE */$redis-&gt;exists('NonExistingKey'); /* FALSE */</pre>incr, incrByDescription<p>Increment the number stored at key by one. If the second argument is filled, it will be used as the integer value of the increment.</p>Parameters<p><em>key</em><em>value</em>: value that will be added to key (only for incrBy)</p>Return value<p><em>INT</em>the new value</p>Examples<pre>$redis-&gt;incr('key1'); /* key1 didn't exists, set to 0 before the increment */                      /* and now has the value 1  */$redis-&gt;incr('key1'); /* 2 */$redis-&gt;incr('key1'); /* 3 */$redis-&gt;incr('key1'); /* 4 */$redis-&gt;incrBy('key1', 10); /* 14 */</pre>decr, decrByDescription<p>Decrement the number stored at key by one. If the second argument is filled, it will be used as the integer value of the decrement.</p>Parameters<p><em>key</em><em>value</em>: value that will be substracted to key (only for decrBy)</p>Return value<p><em>INT</em>the new value</p>Examples<pre>$redis-&gt;decr('key1'); /* key1 didn't exists, set to 0 before the increment */                      /* and now has the value -1  */$redis-&gt;decr('key1'); /* -2 */$redis-&gt;decr('key1'); /* -3 */$redis-&gt;decrBy('key1', 10); /* -13 */</pre>mGet, getMultipleDescription<p>Get the values of all the specified keys. If one or more keys dont exist, the array will contain<code>FALSE</code>at the position of the key.</p>Parameters<p><em>Array</em>: Array containing the list of the keys</p>Return value<p><em>Array</em>: Array containing the values related to keys in argument</p>Examples<pre>$redis-&gt;set('key1', 'value1');$redis-&gt;set('key2', 'value2');$redis-&gt;set('key3', 'value3');$redis-&gt;mGet(array('key1', 'key2', 'key3')); /* array('value1', 'value2', 'value3');$redis-&gt;mGet(array('key0', 'key1', 'key5')); /* array(`FALSE`, 'value2', `FALSE`);</pre>lPushDescription<p>Adds the string value to the head (left) of the list. Creates the list if the key didn't exist. If the key exists and is not a list,<code>FALSE</code>is returned.</p>Parameters<p><em>key</em><em>value</em>String, value to push in key</p>Return value<p><em>LONG</em>The new length of the list in case of success,<code>FALSE</code>in case of Failure.</p>Examples<pre>$redis-&gt;delete('key1');$redis-&gt;lPush('key1', 'C'); // returns 1$redis-&gt;lPush('key1', 'B'); // returns 2$redis-&gt;lPush('key1', 'A'); // returns 3/* key1 now points to the following list: [ 'A', 'B', 'C' ] */</pre>rPushDescription<p>Adds the string value to the tail (right) of the list. Creates the list if the key didn't exist. If the key exists and is not a list,<code>FALSE</code>is returned.</p>Parameters<p><em>key</em><em>value</em>String, value to push in key</p>Return value<p><em>LONG</em>The new length of the list in case of success,<code>FALSE</code>in case of Failure.</p>Examples<pre>$redis-&gt;delete('key1');$redis-&gt;rPush('key1', 'A'); // returns 1$redis-&gt;rPush('key1', 'B'); // returns 2$redis-&gt;rPush('key1', 'C'); // returns 3/* key1 now points to the following list: [ 'A', 'B', 'C' ] */</pre>lPushxDescription<p>Adds the string value to the head (left) of the list if the list exists.</p>Parameters<p><em>key</em><em>value</em>String, value to push in key</p>Return value<p><em>LONG</em>The new length of the list in case of success,<code>FALSE</code>in case of Failure.</p>Examples<pre>$redis-&gt;delete('key1');$redis-&gt;lPushx('key1', 'A'); // returns 0$redis-&gt;lPush('key1', 'A'); // returns 1$redis-&gt;lPushx('key1', 'B'); // returns 2$redis-&gt;lPushx('key1', 'C'); // returns 3/* key1 now points to the following list: [ 'A', 'B', 'C' ] */</pre>rPushxDescription<p>Adds the string value to the tail (right) of the list if the ist exists.<code>FALSE</code>in case of Failure.</p>Parameters<p><em>key</em><em>value</em>String, value to push in key</p>Return value<p><em>LONG</em>The new length of the list in case of success,<code>FALSE</code>in case of Failure.</p>Examples<pre>$redis-&gt;delete('key1');$redis-&gt;rPushx('key1', 'A'); // returns 0$redis-&gt;rPush('key1', 'A'); // returns 1$redis-&gt;rPushx('key1', 'B'); // returns 2$redis-&gt;rPushx('key1', 'C'); // returns 3/* key1 now points to the following list: [ 'A', 'B', 'C' ] */</pre>lPop<em>Description</em><p>Return and remove the first element of the list.</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>STRING</em>if command executed successfully<em>BOOL</em><code>FALSE</code>in case of failure (empty list)</p><em>Example</em><pre>$redis-&gt;rPush('key1', 'A');$redis-&gt;rPush('key1', 'B');$redis-&gt;rPush('key1', 'C'); /* key1 =&gt; [ 'A', 'B', 'C' ] */$redis-&gt;lPop('key1'); /* key1 =&gt; [ 'B', 'C' ] */</pre>rPop<em>Description</em><p>Returns and removes the last element of the list.</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>STRING</em>if command executed successfully<em>BOOL</em><code>FALSE</code>in case of failure (empty list)</p><em>Example</em><pre>$redis-&gt;rPush('key1', 'A');$redis-&gt;rPush('key1', 'B');$redis-&gt;rPush('key1', 'C'); /* key1 =&gt; [ 'A', 'B', 'C' ] */$redis-&gt;rPop('key1'); /* key1 =&gt; [ 'A', 'B' ] */</pre>blPop, brPop<em>Description</em><p>Is a blocking lPop(rPop) primitive. If at least one of the lists contains at least one element, the element will be popped from the head of the list and returned to the caller. Il all the list identified by the keys passed in arguments are empty, blPop will block during the specified timeout until an element is pushed to one of those lists. This element will be popped.</p><em>Parameters</em><p><em>ARRAY</em>Array containing the keys of the lists<em>INTEGER</em>Timeout Or<em>STRING</em>Key1<em>STRING</em>Key2<em>STRING</em>Key3 ...<em>STRING</em>Keyn<em>INTEGER</em>Timeout</p><em>Return value</em><p><em>ARRAY</em>array('listName', 'element')</p><em>Example</em><pre>/* Non blocking feature */$redis-&gt;lPush('key1', 'A');$redis-&gt;delete('key2');$redis-&gt;blPop('key1', 'key2', 10); /* array('key1', 'A') *//* OR */$redis-&gt;blPop(array('key1', 'key2'), 10); /* array('key1', 'A') */$redis-&gt;brPop('key1', 'key2', 10); /* array('key1', 'A') *//* OR */$redis-&gt;brPop(array('key1', 'key2'), 10); /* array('key1', 'A') *//* Blocking feature *//* process 1 */$redis-&gt;delete('key1');$redis-&gt;blPop('key1', 10);/* blocking for 10 seconds *//* process 2 */$redis-&gt;lPush('key1', 'A');/* process 1 *//* array('key1', 'A') is returned*/</pre>lSize<em>Description</em><p>Returns the size of a list identified by Key. If the list didn't exist or is empty, the command returns 0. If the data type identified by Key is not a list, the command return<code>FALSE</code>.</p><em>Parameters</em><p><em>Key</em></p><em>Return value</em><p><em>LONG</em>The size of the list identified by Key exists.<em>BOOL</em><code>FALSE</code>if the data type identified by Key is not list</p><em>Example</em><pre>$redis-&gt;rPush('key1', 'A');$redis-&gt;rPush('key1', 'B');$redis-&gt;rPush('key1', 'C'); /* key1 =&gt; [ 'A', 'B', 'C' ] */$redis-&gt;lSize('key1');/* 3 */$redis-&gt;rPop('key1'); $redis-&gt;lSize('key1');/* 2 */</pre>lIndex, lGet<em>Description</em><p>Return the specified element of the list stored at the specified key. 0 the first element, 1 the second ... -1 the last element, -2 the penultimate ... Return<code>FALSE</code>in case of a bad index or a key that doesn't point to a list.</p><em>Parameters</em><p><em>key</em><em>index</em></p><em>Return value</em><p><em>String</em>the element at this index<em>Bool</em><code>FALSE</code>if the key identifies a non-string data type, or no value corresponds to this index in the list<code>Key</code>.</p><em>Example</em><pre>$redis-&gt;rPush('key1', 'A');$redis-&gt;rPush('key1', 'B');$redis-&gt;rPush('key1', 'C'); /* key1 =&gt; [ 'A', 'B', 'C' ] */$redis-&gt;lGet('key1', 0); /* 'A' */$redis-&gt;lGet('key1', -1); /* 'C' */$redis-&gt;lGet('key1', 10); /* `FALSE` */</pre>lSet<em>Description</em><p>Set the list at index with the new value.</p><em>Parameters</em><p><em>key</em><em>index</em><em>value</em></p><em>Return value</em><p><em>BOOL</em><code>TRUE</code>if the new value is setted.<code>FALSE</code>if the index is out of range, or data type identified by key is not a list.</p><em>Example</em><pre>$redis-&gt;rPush('key1', 'A');$redis-&gt;rPush('key1', 'B');$redis-&gt;rPush('key1', 'C'); /* key1 =&gt; [ 'A', 'B', 'C' ] */$redis-&gt;lGet('key1', 0); /* 'A' */$redis-&gt;lSet('key1', 0, 'X');$redis-&gt;lGet('key1', 0); /* 'X' */ </pre>lRange, lGetRange<em>Description</em><p>Returns the specified elements of the list stored at the specified key in the range [start, end]. start and stop are interpretated as indices: 0 the first element, 1 the second ... -1 the last element, -2 the penultimate ...</p><em>Parameters</em><p><em>key</em><em>start</em><em>end</em></p><em>Return value</em><p><em>Array</em>containing the values in specified range.</p><em>Example</em><pre>$redis-&gt;rPush('key1', 'A');$redis-&gt;rPush('key1', 'B');$redis-&gt;rPush('key1', 'C');$redis-&gt;lRange('key1', 0, -1); /* array('A', 'B', 'C') */</pre>lTrim, listTrim<em>Description</em><p>Trims an existing list so that it will contain only a specified range of elements.</p><em>Parameters</em><p><em>key</em><em>start</em><em>stop</em></p><em>Return value</em><p><em>Array</em><em>Bool</em>return<code>FALSE</code>if the key identify a non-list value.</p><em>Example</em><pre>$redis-&gt;rPush('key1', 'A');$redis-&gt;rPush('key1', 'B');$redis-&gt;rPush('key1', 'C');$redis-&gt;lRange('key1', 0, -1); /* array('A', 'B', 'C') */$redis-&gt;lTrim('key1', 0, 1);$redis-&gt;lRange('key1', 0, -1); /* array('A', 'B') */</pre>lRem, lRemove<em>Description</em><p>Removes the first<code>count</code>occurences of the value element from the list. If count is zero, all the matching elements are removed. If count is negative, elements are removed from tail to head.</p><p>Note: The argument order is not the same as in the Redis documentation. This difference is kept for compatibility reasons.</p><em>Parameters</em><p><em>key</em><em>value</em><em>count</em></p><em>Return value</em><p><em>LONG</em>the number of elements to remove<em>BOOL</em><code>FALSE</code>if the value identified by key is not a list.</p><em>Example</em><pre>$redis-&gt;lPush('key1', 'A');$redis-&gt;lPush('key1', 'B');$redis-&gt;lPush('key1', 'C'); $redis-&gt;lPush('key1', 'A'); $redis-&gt;lPush('key1', 'A'); $redis-&gt;lRange('key1', 0, -1); /* array('A', 'A', 'C', 'B', 'A') */$redis-&gt;lRem('key1', 'A', 2); /* 2 */$redis-&gt;lRange('key1', 0, -1); /* array('C', 'B', 'A') */</pre>lInsert<em>Description</em><p>Insert value in the list before or after the pivot value. the parameter options specify the position of the insert (before or after). If the list didn't exists, or the pivot didn't exists, the value is not inserted.</p><em>Parameters</em><p><em>key</em><em>position</em>Redis::BEFORE | Redis::AFTER<em>pivot</em><em>value</em></p><em>Return value</em><p>The number of the elements in the list, -1 if the pivot didn't exists.</p><em>Example</em><pre>$redis-&gt;delete('key1');$redis-&gt;lInsert('key1', Redis::AFTER, 'A', 'X'); /* 0 */$redis-&gt;lPush('key1', 'A');$redis-&gt;lPush('key1', 'B');$redis-&gt;lPush('key1', 'C');$redis-&gt;lInsert('key1', Redis::BEFORE, 'C', 'X'); /* 4 */$redis-&gt;lRange('key1', 0, -1); /* array('A', 'B', 'X', 'C') */$redis-&gt;lInsert('key1', Redis::AFTER, 'C', 'Y'); /* 5 */$redis-&gt;lRange('key1', 0, -1); /* array('A', 'B', 'X', 'C', 'Y') */$redis-&gt;lInsert('key1', Redis::AFTER, 'W', 'value'); /* -1 */</pre>sAdd<em>Description</em><p>Adds a value to the set value stored at key. If this value is already in the set,<code>FALSE</code>is returned.</p><em>Parameters</em><p><em>key</em><em>value</em></p><em>Return value</em><p><em>BOOL</em><code>TRUE</code>if value didn't exist and was added successfully,<code>FALSE</code>if the value is already present.</p><em>Example</em><pre>$redis-&gt;sAdd('key1' , 'set1'); /* TRUE, 'key1' =&gt; {'set1'} */$redis-&gt;sAdd('key1' , 'set2'); /* TRUE, 'key1' =&gt; {'set1', 'set2'}*/$redis-&gt;sAdd('key1' , 'set2'); /* FALSE, 'key1' =&gt; {'set1', 'set2'}*/</pre>sRem, sRemove<em>Description</em><p>Removes the specified member from the set value stored at key.</p><em>Parameters</em><p><em>key</em><em>member</em></p><em>Return value</em><p><em>BOOL</em><code>TRUE</code>if the member was present in the set,<code>FALSE</code>if it didn't.</p><em>Example</em><pre>$redis-&gt;sAdd('key1' , 'set1'); $redis-&gt;sAdd('key1' , 'set2'); $redis-&gt;sAdd('key1' , 'set3'); /* 'key1' =&gt; {'set1', 'set2', 'set3'}*/$redis-&gt;sRem('key1', 'set2'); /* 'key1' =&gt; {'set1', 'set3'} */</pre>sMove<em>Description</em><p>Moves the specified member from the set at srcKey to the set at dstKey.</p><em>Parameters</em><p><em>srcKey</em><em>dstKey</em><em>member</em></p><em>Return value</em><p><em>BOOL</em>If the operation is successful, return<code>TRUE</code>. If the srcKey and/or dstKey didn't exist, and/or the member didn't exist in srcKey,<code>FALSE</code>is returned.</p><em>Example</em><pre>$redis-&gt;sAdd('key1' , 'set11'); $redis-&gt;sAdd('key1' , 'set12'); $redis-&gt;sAdd('key1' , 'set13'); /* 'key1' =&gt; {'set11', 'set12', 'set13'}*/$redis-&gt;sAdd('key2' , 'set21'); $redis-&gt;sAdd('key2' , 'set22'); /* 'key2' =&gt; {'set21', 'set22'}*/$redis-&gt;sMove('key1', 'key2', 'set13'); /* 'key1' =&gt;  {'set11', 'set12'} */                    /* 'key2' =&gt;  {'set21', 'set22', 'set13'} */</pre>sIsMember, sContains<em>Description</em><p>Checks if<code>value</code>is a member of the set stored at the key<code>key</code>.</p><em>Parameters</em><p><em>key</em><em>value</em></p><em>Return value</em><p><em>BOOL</em><code>TRUE</code>if<code>value</code>is a member of the set at key<code>key</code>,<code>FALSE</code>otherwise.</p><em>Example</em><pre>$redis-&gt;sAdd('key1' , 'set1'); $redis-&gt;sAdd('key1' , 'set2'); $redis-&gt;sAdd('key1' , 'set3'); /* 'key1' =&gt; {'set1', 'set2', 'set3'}*/$redis-&gt;sIsMember('key1', 'set1'); /* TRUE */$redis-&gt;sIsMember('key1', 'setX'); /* FALSE */</pre>sCard, sSize<em>Description</em><p>Returns the cardinality of the set identified by key.</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>LONG</em>the cardinality of the set identified by key, 0 if the set doesn't exist.</p><em>Example</em><pre>$redis-&gt;sAdd('key1' , 'set1'); $redis-&gt;sAdd('key1' , 'set2'); $redis-&gt;sAdd('key1' , 'set3'); /* 'key1' =&gt; {'set1', 'set2', 'set3'}*/$redis-&gt;sCard('key1'); /* 3 */$redis-&gt;sCard('keyX'); /* 0 */</pre>sPop<em>Description</em><p>Removes and returns a random element from the set value at Key.</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>String</em>"popped" value<em>Bool</em><code>FALSE</code>if set identified by key is empty or doesn't exist.</p><em>Example</em><pre>$redis-&gt;sAdd('key1' , 'set1'); $redis-&gt;sAdd('key1' , 'set2'); $redis-&gt;sAdd('key1' , 'set3'); /* 'key1' =&gt; {'set3', 'set1', 'set2'}*/$redis-&gt;sPop('key1'); /* 'set1', 'key1' =&gt; {'set3', 'set2'} */$redis-&gt;sPop('key1'); /* 'set3', 'key1' =&gt; {'set2'} */</pre>sRandMember<em>Description</em><p>Returns a random element from the set value at Key, without removing it.</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>String</em>value from the set<em>Bool</em><code>FALSE</code>if set identified by key is empty or doesn't exist.</p><em>Example</em><pre>$redis-&gt;sAdd('key1' , 'set1'); $redis-&gt;sAdd('key1' , 'set2'); $redis-&gt;sAdd('key1' , 'set3'); /* 'key1' =&gt; {'set3', 'set1', 'set2'}*/$redis-&gt;sRandMember('key1'); /* 'set1', 'key1' =&gt; {'set3', 'set1', 'set2'} */$redis-&gt;sRandMember('key1'); /* 'set3', 'key1' =&gt; {'set3', 'set1', 'set2'} */</pre>sInter<em>Description</em><p>Returns the members of a set resulting from the intersection of all the sets held at the specified keys. If just a single key is specified, then this command produces the members of this set. If one of the keys is missing,<code>FALSE</code>is returned.</p><em>Parameters</em><p>key1, key2, keyN: keys identifying the different sets on which we will apply the intersection.</p><em>Return value</em><p>Array, contain the result of the intersection between those keys. If the intersection beteen the different sets is empty, the return value will be empty array.</p><em>Examples</em><pre>$redis-&gt;sAdd('key1', 'val1');$redis-&gt;sAdd('key1', 'val2');$redis-&gt;sAdd('key1', 'val3');$redis-&gt;sAdd('key1', 'val4');$redis-&gt;sAdd('key2', 'val3');$redis-&gt;sAdd('key2', 'val4');$redis-&gt;sAdd('key3', 'val3');$redis-&gt;sAdd('key3', 'val4');var_dump($redis-&gt;sInter('key1', 'key2', 'key3'));</pre><p>Output:</p><pre>array(2) {  [0]=&gt;  string(4) "val4"  [1]=&gt;  string(4) "val3"}</pre>sInterStore<em>Description</em><p>Performs a sInter command and stores the result in a new set.</p><em>Parameters</em><p><em>Key</em>: dstkey, the key to store the diff into.</p><p><em>Keys</em>: key1, key2... keyN. key1..keyN are intersected as in sInter.</p><em>Return value</em><p><em>INTEGER</em>: The cardinality of the resulting set, or<code>FALSE</code>in case of a missing key.</p><em>Example</em><pre>$redis-&gt;sAdd('key1', 'val1');$redis-&gt;sAdd('key1', 'val2');$redis-&gt;sAdd('key1', 'val3');$redis-&gt;sAdd('key1', 'val4');$redis-&gt;sAdd('key2', 'val3');$redis-&gt;sAdd('key2', 'val4');$redis-&gt;sAdd('key3', 'val3');$redis-&gt;sAdd('key3', 'val4');var_dump($redis-&gt;sInterStore('output', 'key1', 'key2', 'key3'));var_dump($redis-&gt;sMembers('output'));</pre><p>Output:</p><pre>int(2)array(2) {  [0]=&gt;  string(4) "val4"  [1]=&gt;  string(4) "val3"}</pre>sUnion<em>Description</em><p>Performs the union between N sets and returns it.</p><em>Parameters</em><p><em>Keys</em>: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis.</p><em>Return value</em><p><em>Array of strings</em>: The union of all these sets.</p><em>Example</em><pre>$redis-&gt;delete('s0', 's1', 's2');$redis-&gt;sAdd('s0', '1');$redis-&gt;sAdd('s0', '2');$redis-&gt;sAdd('s1', '3');$redis-&gt;sAdd('s1', '1');$redis-&gt;sAdd('s2', '3');$redis-&gt;sAdd('s2', '4');var_dump($redis-&gt;sUnion('s0', 's1', 's2'));</pre><p>Return value: all elements that are either in s0 or in s1 or in s2.</p><pre>array(4) {  [0]=&gt;  string(1) "3"  [1]=&gt;  string(1) "4"  [2]=&gt;  string(1) "1"  [3]=&gt;  string(1) "2"}</pre>sUnionStore<em>Description</em><p>Performs the same action as sUnion, but stores the result in the first key</p><em>Parameters</em><p><em>Key</em>: dstkey, the key to store the diff into.</p><p><em>Keys</em>: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis.</p><em>Return value</em><p><em>INTEGER</em>: The cardinality of the resulting set, or<code>FALSE</code>in case of a missing key.</p><em>Example</em><pre>$redis-&gt;delete('s0', 's1', 's2');$redis-&gt;sAdd('s0', '1');$redis-&gt;sAdd('s0', '2');$redis-&gt;sAdd('s1', '3');$redis-&gt;sAdd('s1', '1');$redis-&gt;sAdd('s2', '3');$redis-&gt;sAdd('s2', '4');var_dump($redis-&gt;sUnionStore('dst', 's0', 's1', 's2'));var_dump($redis-&gt;sMembers('dst'));</pre><p>Return value: the number of elements that are either in s0 or in s1 or in s2.</p><pre>int(4)array(4) {  [0]=&gt;  string(1) "3"  [1]=&gt;  string(1) "4"  [2]=&gt;  string(1) "1"  [3]=&gt;  string(1) "2"}</pre>sDiff<em>Description</em><p>Performs the difference between N sets and returns it.</p><em>Parameters</em><p><em>Keys</em>: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis.</p><em>Return value</em><p><em>Array of strings</em>: The difference of the first set will all the others.</p><em>Example</em><pre>$redis-&gt;delete('s0', 's1', 's2');$redis-&gt;sAdd('s0', '1');$redis-&gt;sAdd('s0', '2');$redis-&gt;sAdd('s0', '3');$redis-&gt;sAdd('s0', '4');$redis-&gt;sAdd('s1', '1');$redis-&gt;sAdd('s2', '3');var_dump($redis-&gt;sDiff('s0', 's1', 's2'));</pre><p>Return value: all elements of s0 that are neither in s1 nor in s2.</p><pre>array(2) {  [0]=&gt;  string(1) "4"  [1]=&gt;  string(1) "2"}</pre>sDiffStore<em>Description</em><p>Performs the same action as sDiff, but stores the result in the first key</p><em>Parameters</em><p><em>Key</em>: dstkey, the key to store the diff into.</p><p><em>Keys</em>: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis</p><em>Return value</em><p><em>INTEGER</em>: The cardinality of the resulting set, or<code>FALSE</code>in case of a missing key.</p><em>Example</em><pre>$redis-&gt;delete('s0', 's1', 's2');$redis-&gt;sAdd('s0', '1');$redis-&gt;sAdd('s0', '2');$redis-&gt;sAdd('s0', '3');$redis-&gt;sAdd('s0', '4');$redis-&gt;sAdd('s1', '1');$redis-&gt;sAdd('s2', '3');var_dump($redis-&gt;sDiffStore('dst', 's0', 's1', 's2'));var_dump($redis-&gt;sMembers('dst'));</pre><p>Return value: the number of elements of s0 that are neither in s1 nor in s2.</p><pre>int(2)array(2) {  [0]=&gt;  string(1) "4"  [1]=&gt;  string(1) "2"}</pre>sMembers, sGetMembers<em>Description</em><p>Returns the contents of a set.</p><em>Parameters</em><p><em>Key</em>: key</p><em>Return value</em><p>An array of elements, the contents of the set.</p><em>Example</em><pre>$redis-&gt;delete('s');$redis-&gt;sAdd('s', 'a');$redis-&gt;sAdd('s', 'b');$redis-&gt;sAdd('s', 'a');$redis-&gt;sAdd('s', 'c');var_dump($redis-&gt;sMembers('s'));</pre><p>Output:</p><pre>array(3) {  [0]=&gt;  string(1) "c"  [1]=&gt;  string(1) "a"  [2]=&gt;  string(1) "b"}</pre><p>The order is random and corresponds to redis' own internal representation of the set structure.</p>getSet<em>Description</em><p>Sets a value and returns the previous entry at that key.</p><em>Parameters</em><p><em>Key</em>: key</p><p><em>STRING</em>: value</p><em>Return value</em><p>A string, the previous value located at this key.</p><em>Example</em><pre>$redis-&gt;set('x', '42');$exValue = $redis-&gt;getSet('x', 'lol');  // return '42', replaces x by 'lol'$newValue = $redis-&gt;get('x')'       // return 'lol'</pre>randomKey<em>Description</em><p>Returns a random key.</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>STRING</em>: an existing key in redis.</p><em>Example</em><pre>$key = $redis-&gt;randomKey();$surprise = $redis-&gt;get($key);  // who knows what's in there.</pre>select<em>Description</em><p>Switches to a given database.</p><em>Parameters</em><p><em>INTEGER</em>: dbindex, the database number to switch to.</p><em>Return value</em><p><code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><p>(See following function)</p>move<em>Description</em><p>Moves a key to a different database.</p><em>Parameters</em><p><em>Key</em>: key, the key to move.</p><p><em>INTEGER</em>: dbindex, the database number to move the key to.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;select(0);  // switch to DB 0$redis-&gt;set('x', '42'); // write 42 to x$redis-&gt;move('x', 1);   // move to DB 1$redis-&gt;select(1);  // switch to DB 1$redis-&gt;get('x');   // will return 42</pre>rename, renameKey<em>Description</em><p>Renames a key.</p><em>Parameters</em><p><em>STRING</em>: srckey, the key to rename.</p><p><em>STRING</em>: dstkey, the new name for the key.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;set('x', '42');$redis-&gt;rename('x', 'y');$redis-&gt;get('y');   // &rarr; 42$redis-&gt;get('x');   // &rarr; `FALSE`</pre>renameNx<em>Description</em><p>Same as rename, but will not replace a key if the destination already exists. This is the same behaviour as setNx.</p>setTimeout, expire<em>Description</em><p>Sets an expiration date (a timeout) on an item.</p><em>Parameters</em><p><em>Key</em>: key. The key that will disappear.</p><p><em>Integer</em>: ttl. The key's remaining Time To Live, in seconds.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;set('x', '42');$redis-&gt;setTimeout('x', 3); // x will disappear in 3 seconds.sleep(5);               // wait 5 seconds$redis-&gt;get('x');       // will return `FALSE`, as 'x' has expired.</pre>expireAt<em>Description</em><p>Sets an expiration date (a timestamp) on an item.</p><em>Parameters</em><p><em>Key</em>: key. The key that will disappear.</p><p><em>Integer</em>: Unix timestamp. The key's date of death, in seconds from Epoch time.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;set('x', '42');$now = time(NULL); // current timestamp$redis-&gt;expireAt('x', $now + 3);    // x will disappear in 3 seconds.sleep(5);               // wait 5 seconds$redis-&gt;get('x');       // will return `FALSE`, as 'x' has expired.</pre>keys, getKeys<em>Description</em><p>Returns the keys that match a certain pattern.</p><em>Description</em><em>Parameters</em><p><em>STRING</em>: pattern, using '*' as a wildcard.</p><em>Return value</em><p><em>Array of STRING</em>: The keys that match a certain pattern.</p><em>Example</em><pre>$allKeys = $redis-&gt;keys('*');   // all keys will match this.$keyWithUserPrefix = $redis-&gt;keys('user*');</pre>dbSize<em>Description</em><p>Returns the current database's size.</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>INTEGER</em>: DB size, in number of keys.</p><em>Example</em><pre>$count = $redis-&gt;dbSize();echo "Redis has $count keys\n";</pre>auth<em>Description</em><p>Authenticate the connection using a password.<em>Warning</em>: The password is sent in plain-text over the network.</p><em>Parameters</em><p><em>STRING</em>: password</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>if the connection is authenticated,<code>FALSE</code>otherwise.</p><em>Example</em><pre>$redis-&gt;auth('foobared');</pre>bgrewriteaof<em>Description</em><p>Starts the background rewrite of AOF (Append-Only File)</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;bgrewriteaof();</pre>slaveof<em>Description</em><p>Changes the slave status</p><em>Parameters</em><p>Either host (string) and port (int), or no parameter to stop being a slave.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;slaveof('10.0.1.7', 6379);/* ... */$redis-&gt;slaveof();</pre>object<em>Description</em><p>Describes the object pointed to by a key.</p><em>Parameters</em><p>The information to retrieve (string) and the key (string). Info can be one of the following:</p>"encoding""refcount""idletime"<em>Return value</em><p><em>STRING</em>for "encoding",<em>LONG</em>for "refcount" and "idletime",<code>FALSE</code>if the key doesn't exist.</p><em>Example</em><pre>$redis-&gt;object("encoding", "l"); // &rarr; ziplist$redis-&gt;object("refcount", "l"); // &rarr; 1$redis-&gt;object("idletime", "l"); // &rarr; 400 (in seconds, with a precision of 10 seconds).</pre>save<em>Description</em><p>Performs a synchronous save.</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure. If a save is already running, this command will fail and return<code>FALSE</code>.</p><em>Example</em><pre>$redis-&gt;save();</pre>bgsave<em>Description</em><p>Performs a background save.</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure. If a save is already running, this command will fail and return<code>FALSE</code>.</p><em>Example</em><pre>$redis-&gt;bgSave();</pre>lastSave<em>Description</em><p>Returns the timestamp of the last disk save.</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>INT</em>: timestamp.</p><em>Example</em><pre>$redis-&gt;lastSave();</pre>type<em>Description</em><p>Returns the type of data pointed by a given key.</p><em>Parameters</em><p><em>Key</em>: key</p><em>Return value</em><p>Depending on the type of the data pointed by the key, this method will return the following value:string: Redis::REDIS_STRINGset: Redis::REDIS_SETlist: Redis::REDIS_LISTzset: Redis::REDIS_ZSEThash: Redis::REDIS_HASHother: Redis::REDIS_NOT_FOUND</p><em>Example</em><pre>$redis-&gt;type('key');</pre>append<em>Description</em><p>Append specified string to the string stored in specified key.</p><em>Parameters</em><p><em>Key</em><em>Value</em></p><em>Return value</em><p><em>INTEGER</em>: Size of the value after the append</p><em>Example</em><pre>$redis-&gt;set('key', 'value1');$redis-&gt;append('key', 'value2'); /* 12 */$redis-&gt;get('key'); /* 'value1value2' */</pre>getRange (substr also supported but deprecated in redis)<em>Description</em><p>Return a substring of a larger string</p><em>Parameters</em><p><em>key</em><em>start</em><em>end</em></p><em>Return value</em><p><em>STRING</em>: the substring</p><em>Example</em><pre>$redis-&gt;set('key', 'string value');$redis-&gt;getRange('key', 0, 5); /* 'string' */$redis-&gt;getRange('key', -5, -1); /* 'value' */</pre>setRange<em>Description</em><p>Changes a substring of a larger string.</p><em>Parameters</em><p><em>key</em><em>offset</em><em>value</em></p><em>Return value</em><p><em>STRING</em>: the length of the string after it was modified.</p><em>Example</em><pre>$redis-&gt;set('key', 'Hello world');$redis-&gt;setRange('key', 6, "redis"); /* returns 11 */$redis-&gt;get('key'); /* "Hello redis" */</pre>strlen<em>Description</em><p>Get the length of a string value.</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>INTEGER</em></p><em>Example</em><pre>$redis-&gt;set('key', 'value');$redis-&gt;strlen('key'); /* 5 */</pre>getBit<em>Description</em><p>Return a single bit out of a larger string</p><em>Parameters</em><p><em>key</em><em>offset</em></p><em>Return value</em><p><em>LONG</em>: the bit value (0 or 1)</p><em>Example</em><pre>$redis-&gt;set('key', "\x7f"); // this is 0111 1111$redis-&gt;getBit('key', 0); /* 0 */$redis-&gt;getBit('key', 1); /* 1 */</pre>setBit<em>Description</em><p>Changes a single bit of a string.</p><em>Parameters</em><p><em>key</em><em>offset</em><em>value</em>: bool or int (1 or 0)</p><em>Return value</em><p><em>LONG</em>: 0 or 1, the value of the bit before it was set.</p><em>Example</em><pre>$redis-&gt;set('key', "*");    // ord("*") = 42 = 0x2f = "0010 1010"$redis-&gt;setBit('key', 5, 1); /* returns 0 */$redis-&gt;setBit('key', 7, 1); /* returns 0 */$redis-&gt;get('key'); /* chr(0x2f) = "/" = b("0010 1111") */</pre>flushDB<em>Description</em><p>Removes all entries from the current database.</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>BOOL</em>: Always<code>TRUE</code>.</p><em>Example</em><pre>$redis-&gt;flushDB();</pre>flushAll<em>Description</em><p>Removes all entries from all databases.</p><em>Parameters</em><p>None.</p><em>Return value</em><p><em>BOOL</em>: Always<code>TRUE</code>.</p><em>Example</em><pre>$redis-&gt;flushAll();</pre>sort<em>Description</em><em>Parameters</em><p><em>Key</em>: key<em>Options</em>: array(key =&gt; value, ...) - optional, with the following keys and values:</p><pre>    'by' =&gt; 'some_pattern_*',    'limit' =&gt; array(0, 1),    'get' =&gt; 'some_other_pattern_*' or an array of patterns,    'sort' =&gt; 'asc' or 'desc',    'alpha' =&gt; TRUE,    'store' =&gt; 'external-key'</pre><em>Return value</em><p>An array of values, or a number corresponding to the number of elements stored if that was used.</p><em>Example</em><pre>$redis-&gt;delete('s');$redis-&gt;sadd('s', 5);$redis-&gt;sadd('s', 4);$redis-&gt;sadd('s', 2);$redis-&gt;sadd('s', 1);$redis-&gt;sadd('s', 3);var_dump($redis-&gt;sort('s')); // 1,2,3,4,5var_dump($redis-&gt;sort('s', array('sort' =&gt; 'desc'))); // 5,4,3,2,1var_dump($redis-&gt;sort('s', array('sort' =&gt; 'desc', 'store' =&gt; 'out'))); // (int)5</pre>info<em>Description</em><p>Returns an associative array of strings and integers, with the following keys:</p>redis_versionarch_bitsuptime_in_secondsuptime_in_daysconnected_clientsconnected_slavesused_memorychanges_since_last_savebgsave_in_progresslast_save_timetotal_connections_receivedtotal_commands_processedrole<em>Parameters</em><p>None.</p><em>Example</em><pre>$redis-&gt;info();</pre>resetStat<em>Description</em><p>Resets the statistics reported by Redis using the INFO command (<code>info()</code>function).</p><p>These are the counters that are reset:</p>Keyspace hitsKeyspace missesNumber of commands processedNumber of connections receivedNumber of expired keys<em>Parameters</em><p>None.</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;resetStat();</pre>ttl<em>Description</em><p>Returns the time to live left for a given key, in seconds. If the key doesn't exist,<code>FALSE</code>is returned.</p><em>Parameters</em><p><em>Key</em>: key</p><em>Return value</em><p>Long, the time left to live in seconds.</p><em>Example</em><pre>$redis-&gt;ttl('key');</pre>persist<em>Description</em><p>Remove the expiration timer from a key.</p><em>Parameters</em><p><em>Key</em>: key</p><em>Return value</em><p><em>BOOL</em>:<code>TRUE</code>if a timeout was removed,<code>FALSE</code>if the key didn&rsquo;t exist or didn&rsquo;t have an expiration timer.</p><em>Example</em><pre>$redis-&gt;persist('key');</pre>mset, msetnx<em>Description</em><p>Sets multiple key-value pairs in one atomic command. MSETNX only returns TRUE if all the keys were set (see SETNX).</p><em>Parameters</em><p><em>Pairs</em>: array(key =&gt; value, ...)</p><em>Return value</em><p><em>Bool</em><code>TRUE</code>in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;mset(array('key0' =&gt; 'value0', 'key1' =&gt; 'value1'));var_dump($redis-&gt;get('key0'));var_dump($redis-&gt;get('key1'));</pre><p>Output:</p><pre>string(6) "value0"string(6) "value1"</pre>rpoplpush (redis &gt;= 1.1)<em>Description</em><p>Pops a value from the tail of a list, and pushes it to the front of another list. Also return this value.</p><em>Parameters</em><p><em>Key</em>: srckey<em>Key</em>: dstkey</p><em>Return value</em><p><em>STRING</em>The element that was moved in case of success,<code>FALSE</code>in case of failure.</p><em>Example</em><pre>$redis-&gt;delete('x', 'y');$redis-&gt;lPush('x', 'abc');$redis-&gt;lPush('x', 'def');$redis-&gt;lPush('y', '123');$redis-&gt;lPush('y', '456');// move the last of x to the front of y.var_dump($redis-&gt;rpoplpush('x', 'y'));var_dump($redis-&gt;lRange('x', 0, -1));var_dump($redis-&gt;lRange('y', 0, -1));</pre><p>Output:</p><pre>string(3) "abc"array(1) {  [0]=&gt;  string(3) "def"}array(3) {  [0]=&gt;  string(3) "abc"  [1]=&gt;  string(3) "456"  [2]=&gt;  string(3) "123"}</pre>brpoplpush<em>Description</em><p>A blocking version of<code>rpoplpush</code>, with an integral timeout in the third parameter.</p><em>Parameters</em><p><em>Key</em>: srckey<em>Key</em>: dstkey<em>Long</em>: timeout</p><em>Return value</em><p><em>STRING</em>The element that was moved in case of success,<code>FALSE</code>in case of timeout.</p>zAdd<em>Description</em><p>Adds the specified member with a given score to the sorted set stored at key.</p><em>Parameters</em><p><em>key</em><em>score</em>: double<em>value</em>: string</p><em>Return value</em><p><em>Long</em>1 if the element is added. 0 otherwise.</p><em>Example</em><pre>$redis-&gt;zAdd('key', 1, 'val1');$redis-&gt;zAdd('key', 0, 'val0');$redis-&gt;zAdd('key', 5, 'val5');$redis-&gt;zRange('key', 0, -1); // array(val0, val1, val5)</pre>zRange<em>Description</em><p>Returns a range of elements from the ordered set stored at the specified key, with values in the range [start, end]. start and stop are interpreted as zero-based indices: 0 the first element, 1 the second ... -1 the last element, -2 the penultimate ...</p><em>Parameters</em><p><em>key</em><em>start</em>: long<em>end</em>: long<em>withscores</em>: bool = false</p><em>Return value</em><p><em>Array</em>containing the values in specified range.</p><em>Example</em><pre>$redis-&gt;zAdd('key1', 0, 'val0');$redis-&gt;zAdd('key1', 2, 'val2');$redis-&gt;zAdd('key1', 10, 'val10');$redis-&gt;zRange('key1', 0, -1); /* array('val0', 'val2', 'val10') */// with scores$redis-&gt;zRange('key1', 0, -1, true); /* array('val0' =&gt; 0, 'val2' =&gt; 2, 'val10' =&gt; 10) */</pre>zDelete, zRem<em>Description</em><p>Deletes a specified member from the ordered set.</p><em>Parameters</em><p><em>key</em><em>member</em></p><em>Return value</em><p><em>LONG</em>1 on success, 0 on failure.</p><em>Example</em><pre>$redis-&gt;zAdd('key', 0, 'val0');$redis-&gt;zAdd('key', 2, 'val2');$redis-&gt;zAdd('key', 10, 'val10');$redis-&gt;zDelete('key', 'val2');$redis-&gt;zRange('key', 0, -1); /* array('val0', 'val10') */</pre>zRevRange<em>Description</em><p>Returns the elements of the sorted set stored at the specified key in the range [start, end] in reverse order. start and stop are interpretated as zero-based indices: 0 the first element, 1 the second ... -1 the last element, -2 the penultimate ...</p><em>Parameters</em><p><em>key</em><em>start</em>: long<em>end</em>: long<em>withscores</em>: bool = false</p><em>Return value</em><p><em>Array</em>containing the values in specified range.</p><em>Example</em><pre>$redis-&gt;zAdd('key', 0, 'val0');$redis-&gt;zAdd('key', 2, 'val2');$redis-&gt;zAdd('key', 10, 'val10');$redis-&gt;zRevRange('key', 0, -1); /* array('val10', 'val2', 'val0') */// with scores$redis-&gt;zRevRange('key', 0, -1, true); /* array('val10' =&gt; 10, 'val2' =&gt; 2, 'val0' =&gt; 0) */</pre>zRangeByScore, zRevRangeByScore<em>Description</em><p>Returns the elements of the sorted set stored at the specified key which have scores in the range [start,end]. Adding a parenthesis before<code>start</code>or<code>end</code>excludes it from the range. +inf and -inf are also valid limits. zRevRangeByScore returns the same items in reverse order, when the<code>start</code>and<code>end</code>parameters are swapped.</p><em>Parameters</em><p><em>key</em><em>start</em>: string<em>end</em>: string<em>options</em>: array</p><p>Two options are available:<code>withscores =&gt; TRUE</code>, and<code>limit =&gt; array($offset, $count)</code></p><em>Return value</em><p><em>Array</em>containing the values in specified range.</p><em>Example</em><pre>$redis-&gt;zAdd('key', 0, 'val0');$redis-&gt;zAdd('key', 2, 'val2');$redis-&gt;zAdd('key', 10, 'val10');$redis-&gt;zRangeByScore('key', 0, 3); /* array('val0', 'val2') */$redis-&gt;zRangeByScore('key', 0, 3, array('withscores' =&gt; TRUE); /* array('val0' =&gt; 0, 'val2' =&gt; 2) */$redis-&gt;zRangeByScore('key', 0, 3, array('limit' =&gt; array(1, 1)); /* array('val2' =&gt; 2) */$redis-&gt;zRangeByScore('key', 0, 3, array('limit' =&gt; array(1, 1)); /* array('val2') */$redis-&gt;zRangeByScore('key', 0, 3, array('withscores' =&gt; TRUE, 'limit' =&gt; array(1, 1)); /* array('val2' =&gt; 2) */</pre>zCount<em>Description</em><p>Returns the<em>number</em>of elements of the sorted set stored at the specified key which have scores in the range [start,end]. Adding a parenthesis before<code>start</code>or<code>end</code>excludes it from the range. +inf and -inf are also valid limits.</p><em>Parameters</em><p><em>key</em><em>start</em>: string<em>end</em>: string</p><em>Return value</em><p><em>LONG</em>the size of a corresponding zRangeByScore.</p><em>Example</em><pre>$redis-&gt;zAdd('key', 0, 'val0');$redis-&gt;zAdd('key', 2, 'val2');$redis-&gt;zAdd('key', 10, 'val10');$redis-&gt;zCount('key', 0, 3); /* 2, corresponding to array('val0', 'val2') */</pre>zRemRangeByScore, zDeleteRangeByScore<em>Description</em><p>Deletes the elements of the sorted set stored at the specified key which have scores in the range [start,end].</p><em>Parameters</em><p><em>key</em><em>start</em>: double or "+inf" or "-inf" string<em>end</em>: double or "+inf" or "-inf" string</p><em>Return value</em><p><em>LONG</em>The number of values deleted from the sorted set</p><em>Example</em><pre>$redis-&gt;zAdd('key', 0, 'val0');$redis-&gt;zAdd('key', 2, 'val2');$redis-&gt;zAdd('key', 10, 'val10');$redis-&gt;zRemRangeByScore('key', 0, 3); /* 2 */</pre>zRemRangeByRank, zDeleteRangeByRank<em>Description</em><p>Deletes the elements of the sorted set stored at the specified key which have rank in the range [start,end].</p><em>Parameters</em><p><em>key</em><em>start</em>: LONG<em>end</em>: LONG</p><em>Return value</em><p><em>LONG</em>The number of values deleted from the sorted set</p><em>Example</em><pre>$redis-&gt;zAdd('key', 1, 'one');$redis-&gt;zAdd('key', 2, 'two');$redis-&gt;zAdd('key', 3, 'three');$redis-&gt;zRemRangeByRank('key', 0, 1); /* 2 */$redis-&gt;zRange('key', 0, -1, array('withscores' =&gt; TRUE)); /* array('three' =&gt; 3) */</pre>zSize, zCard<em>Description</em><p>Returns the cardinality of an ordered set.</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>Long</em>, the set's cardinality</p><em>Example</em><pre>$redis-&gt;zAdd('key', 0, 'val0');$redis-&gt;zAdd('key', 2, 'val2');$redis-&gt;zAdd('key', 10, 'val10');$redis-&gt;zSize('key'); /* 3 */</pre>zScore<em>Description</em><p>Returns the score of a given member in the specified sorted set.</p><em>Parameters</em><p><em>key</em><em>member</em></p><em>Return value</em><p><em>Double</em></p><em>Example</em><pre>$redis-&gt;zAdd('key', 2.5, 'val2');$redis-&gt;zScore('key', 'val2'); /* 2.5 */</pre>zRank, zRevRank<em>Description</em><p>Returns the rank of a given member in the specified sorted set, starting at 0 for the item with the smallest score. zRevRank starts at 0 for the item with the<em>largest</em>score.</p><em>Parameters</em><p><em>key</em><em>member</em></p><em>Return value</em><p><em>Long</em>, the item's score.</p><em>Example</em><pre>$redis-&gt;delete('z');$redis-&gt;zAdd('key', 1, 'one');$redis-&gt;zAdd('key', 2, 'two');$redis-&gt;zRank('key', 'one'); /* 0 */$redis-&gt;zRank('key', 'two'); /* 1 */$redis-&gt;zRevRank('key', 'one'); /* 1 */$redis-&gt;zRevRank('key', 'two'); /* 0 */</pre>zIncrByDescription<p>Increments the score of a member from a sorted set by a given amount.</p>Parameters<p><em>key</em><em>value</em>: (double) value that will be added to the member's score<em>member</em></p>Return value<p><em>DOUBLE</em>the new value</p>Examples<pre>$redis-&gt;delete('key');$redis-&gt;zIncrBy('key', 2.5, 'member1'); /* key or member1 didn't exist, so member1's score is to 0 before the increment */                      /* and now has the value 2.5  */$redis-&gt;zIncrBy('key', 1, 'member1'); /* 3.5 */</pre>zUnion<em>Description</em><p>Creates an union of sorted sets given in second argument. The result of the union will be stored in the sorted set defined by the first argument. The third optionnel argument defines<code>weights</code>to apply to the sorted sets in input. In this case, the<code>weights</code>will be multiplied by the score of each element in the sorted set before applying the aggregation. The forth argument defines the<code>AGGREGATE</code>option which specify how the results of the union are aggregated.</p><em>Parameters</em><p><em>keyOutput</em><em>arrayZSetKeys</em><em>arrayWeights</em><em>aggregateFunction</em>Either "SUM", "MIN", or "MAX": defines the behaviour to use on duplicate entries during the zUnion.</p><em>Return value</em><p><em>LONG</em>The number of values in the new sorted set.</p><em>Example</em><pre>$redis-&gt;delete('k1');$redis-&gt;delete('k2');$redis-&gt;delete('k3');$redis-&gt;delete('ko1');$redis-&gt;delete('ko2');$redis-&gt;delete('ko3');$redis-&gt;zAdd('k1', 0, 'val0');$redis-&gt;zAdd('k1', 1, 'val1');$redis-&gt;zAdd('k2', 2, 'val2');$redis-&gt;zAdd('k2', 3, 'val3');$redis-&gt;zUnion('ko1', array('k1', 'k2')); /* 4, 'ko1' =&gt; array('val0', 'val1', 'val2', 'val3') *//* Weighted zUnion */$redis-&gt;zUnion('ko2', array('k1', 'k2'), array(1, 1)); /* 4, 'ko1' =&gt; array('val0', 'val1', 'val2', 'val3') */$redis-&gt;zUnion('ko3', array('k1', 'k2'), array(5, 1)); /* 4, 'ko1' =&gt; array('val0', 'val2', 'val3', 'val1') */</pre>zInter<em>Description</em><p>Creates an intersection of sorted sets given in second argument. The result of the union will be stored in the sorted set defined by the first argument. The third optionnel argument defines<code>weights</code>to apply to the sorted sets in input. In this case, the<code>weights</code>will be multiplied by the score of each element in the sorted set before applying the aggregation. The forth argument defines the<code>AGGREGATE</code>option which specify how the results of the union are aggregated.</p><em>Parameters</em><p><em>keyOutput</em><em>arrayZSetKeys</em><em>arrayWeights</em><em>aggregateFunction</em>Either "SUM", "MIN", or "MAX": defines the behaviour to use on duplicate entries during the zInter.</p><em>Return value</em><p><em>LONG</em>The number of values in the new sorted set.</p><em>Example</em><pre>$redis-&gt;delete('k1');$redis-&gt;delete('k2');$redis-&gt;delete('k3');$redis-&gt;delete('ko1');$redis-&gt;delete('ko2');$redis-&gt;delete('ko3');$redis-&gt;delete('ko4');$redis-&gt;zAdd('k1', 0, 'val0');$redis-&gt;zAdd('k1', 1, 'val1');$redis-&gt;zAdd('k1', 3, 'val3');$redis-&gt;zAdd('k2', 2, 'val1');$redis-&gt;zAdd('k2', 3, 'val3');$redis-&gt;zInter('ko1', array('k1', 'k2'));               /* 2, 'ko1' =&gt; array('val1', 'val3') */$redis-&gt;zInter('ko2', array('k1', 'k2'), array(1, 1));  /* 2, 'ko2' =&gt; array('val1', 'val3') *//* Weighted zInter */$redis-&gt;zInter('ko3', array('k1', 'k2'), array(1, 5), 'min'); /* 2, 'ko3' =&gt; array('val1', 'val3') */$redis-&gt;zInter('ko4', array('k1', 'k2'), array(1, 5), 'max'); /* 2, 'ko4' =&gt; array('val3', 'val1') */</pre>hSet<em>Description</em><p>Adds a value to the hash stored at key. If this value is already in the hash,<code>FALSE</code>is returned.</p><em>Parameters</em><p><em>key</em><em>hashKey</em><em>value</em></p><em>Return value</em><p><em>LONG</em><code>1</code>if value didn't exist and was added successfully,<code>0</code>if the value was already present and was replaced,<code>FALSE</code>if there was an error.</p><em>Example</em><pre>$redis-&gt;delete('h')$redis-&gt;hSet('h', 'key1', 'hello'); /* 1, 'key1' =&gt; 'hello' in the hash at "h" */$redis-&gt;hGet('h', 'key1'); /* returns "hello" */$redis-&gt;hSet('h', 'key1', 'plop'); /* 0, value was replaced. */$redis-&gt;hGet('h', 'key1'); /* returns "plop" */</pre>hSetNx<em>Description</em><p>Adds a value to the hash stored at key only if this field isn't already in the hash.</p><em>Return value</em><p><em>BOOL</em><code>TRUE</code>if the field was set,<code>FALSE</code>if it was already present.</p><em>Example</em><pre>$redis-&gt;delete('h')$redis-&gt;hSetNx('h', 'key1', 'hello'); /* TRUE, 'key1' =&gt; 'hello' in the hash at "h" */$redis-&gt;hSetNx('h', 'key1', 'world'); /* FALSE, 'key1' =&gt; 'hello' in the hash at "h". No change since the field wasn't replaced. */</pre>hGet<em>Description</em><p>Gets a value from the hash stored at key. If the hash table doesn't exist, or the key doesn't exist,<code>FALSE</code>is returned.</p><em>Parameters</em><p><em>key</em><em>hashKey</em></p><em>Return value</em><p><em>STRING</em>The value, if the command executed successfully<em>BOOL</em><code>FALSE</code>in case of failure</p>hLen<em>Description</em><p>Returns the length of a hash, in number of items</p><em>Parameters</em><p><em>key</em></p><em>Return value</em><p><em>LONG</em>the number of items in a hash,<code>FALSE</code>if the key doesn't exist or isn't a hash.</p><em>Example</em><pre>$redis-&gt;delete('h')$redis-&gt;hSet('h', 'key1', 'hello');$redis-&gt;hSet('h', 'key2', 'plop');$redis-&gt;hLen('h'); /* returns 2 */</pre>hDel<em>Description</em><p>Removes a value from the hash stored at key. If the hash table doesn't exist, or the key doesn't exist,<code>FALSE</code>is returned.</p><em>Parameters</em><p><em>key</em><em>hashKey</em></p><em>Return value</em><p><em>BOOL</em><code>TRUE</code>in case of success,<code>FALSE</code>in case of failure</p>hKeys<em>Description</em><p>Returns the keys in a hash, as an array of strings.</p><em>Parameters</em><p><em>Key</em>: key</p><em>Return value</em><p>An array of elements, the keys of the hash. This works like PHP's array_keys().</p><em>Example</em><pre>$redis-&gt;delete('h');$redis-&gt;hSet('h', 'a', 'x');$redis-&gt;hSet('h', 'b', 'y');$redis-&gt;hSet('h', 'c', 'z');$redis-&gt;hSet('h', 'd', 't');var_dump($redis-&gt;hKeys('h'));</pre><p>Output:</p><pre>array(4) {  [0]=&gt;  string(1) "a"  [1]=&gt;  string(1) "b"  [2]=&gt;  string(1) "c"  [3]=&gt;  string(1) "d"}</pre><p>The order is random and corresponds to redis' own internal representation of the set structure.</p>hVals<em>Description</em><p>Returns the values in a hash, as an array of strings.</p><em>Parameters</em><p><em>Key</em>: key</p><em>Return value</em><p>An array of elements, the values of the hash. This works like PHP's array_values().</p><em>Example</em><pre>$redis-&gt;delete('h');$redis-&gt;hSet('h', 'a', 'x');$redis-&gt;hSet('h', 'b', 'y');$redis-&gt;hSet('h', 'c', 'z');$redis-&gt;hSet('h', 'd', 't');var_dump($redis-&gt;hVals('h'));</pre><p>Output:</p><pre>array(4) {  [0]=&gt;  string(1) "x"  [1]=&gt;  string(1) "y"  [2]=&gt;  string(1) "z"  [3]=&gt;  string(1) "t"}</pre><p>The order is random and corresponds to redis' own internal representation of the set structure.</p>hGetAll<em>Description</em><p>Returns the whole hash, as an array of strings indexed by strings.</p><em>Parameters</em><p><em>Key</em>: key</p><em>Return value</em><p>An array of elements, the contents of the hash.</p><em>Example</em><pre>$redis-&gt;delete('h');$redis-&gt;hSet('h', 'a', 'x');$redis-&gt;hSet('h', 'b', 'y');$redis-&gt;hSet('h', 'c', 'z');$redis-&gt;hSet('h', 'd', 't');var_dump($redis-&gt;hGetAll('h'));</pre><p>Output:</p><pre>array(4) {  ["a"]=&gt;  string(1) "x"  ["b"]=&gt;  string(1) "y"  ["c"]=&gt;  string(1) "z"  ["d"]=&gt;  string(1) "t"}</pre><p>The order is random and corresponds to redis' own internal representation of the set structure.</p>hExistsDescription<p>Verify if the specified member exists in a key.</p>Parameters<p><em>key</em><em>memberKey</em></p>Return value<p><em>BOOL</em>: If the member exists in the hash table, return<code>TRUE</code>, otherwise return<code>FALSE</code>.</p>Examples<pre>$redis-&gt;hSet('h', 'a', 'x');$redis-&gt;hExists('h', 'a'); /*  TRUE */$redis-&gt;hExists('h', 'NonExistingKey'); /* FALSE */</pre>hIncrByDescription<p>Increments the value of a member from a hash by a given amount.</p>Parameters<p><em>key</em><em>member</em><em>value</em>: (integer) value that will be added to the member's value</p>Return value<p><em>LONG</em>the new value</p>Examples<pre>$redis-&gt;delete('h');$redis-&gt;hIncrBy('h', 'x', 2); /* returns 2: h[x] = 2 now. */$redis-&gt;hIncrBy('h', 'x', 1); /* h[x] &larr; 2 + 1. Returns 3 */</pre>hMsetDescription<p>Fills in a whole hash. Non-string values are converted to string, using the standard<code>(string)</code>cast. NULL values are stored as empty strings.</p>Parameters<p><em>key</em><em>members</em>: key &rarr; value array</p>Return value<p><em>BOOL</em></p>Examples<pre>$redis-&gt;delete('user:1');$redis-&gt;hMset('user:1', array('name' =&gt; 'Joe', 'salary' =&gt; 2000));$redis-&gt;hIncrBy('user:1', 'salary', 100); // Joe earns 100 more now.</pre>hMGetDescription<p>Retrieve the values associated to the specified fields in the hash.</p>Parameters<p><em>key</em><em>memberKeys</em>Array</p>Return value<p><em>Array</em>An array of elements, the values of the specified fields in the hash, with the hash keys as array keys.</p>Examples<pre>$redis-&gt;delete('h');$redis-&gt;hSet('h', 'field1', 'value1');$redis-&gt;hSet('h', 'field2', 'value2');$redis-&gt;hmGet('h', array('field1', 'field2')); /* returns array('field1' =&gt; 'value1', 'field2' =&gt; 'value2') */</pre>configDescription<p>Get or Set the redis config keys.</p>Parameters<p><em>operation</em>(string) either<code>GET</code>or<code>SET</code><em>key</em>string for<code>SET</code>, glob-pattern for<code>GET</code>. Seehttp://redis.io/commands/config-getfor examples.<em>value</em>optional string (only for<code>SET</code>)</p>Return value<p><em>Associative array</em>for<code>GET</code>, key -&gt; value<em>bool</em>for<code>SET</code></p>Examples<pre>$redis-&gt;config("GET", "*max-*-entries*");$redis-&gt;config("SET", "dir", "/var/run/redis/dumps/");https://github.com/nicolasff/phpredis/blob/master/README.markdown</pre>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>