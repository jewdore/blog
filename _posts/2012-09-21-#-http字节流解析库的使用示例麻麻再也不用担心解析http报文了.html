---
layout: post
title: # Http字节流解析库的使用示例, 麻麻再也不用担心解析HTTP报文了 #
---

<p>库文件下载: https://github.com/joyent/http-parser</p><p>需要的库文件包括: http_parser.h, http_parser.c</p><p>介绍：基于字节流的HTTP协议解析库，采用回调函数机制，分别在header, message不同阶段触发回调. 由于其采用字节流, 传入的BUFFER无需准确指定HTTP包边界, 所以对于开发HTTP服务器解析HTTP报文非常易用, 通过下面的测试用例可以很快的掌握如何解析HTTP并获得各个字段的值, 比较全面.</p><p>目录结构如下:</p><blockquote><p>./bin/main./bin./src/main.o./src/main.c./src/http_parser.c./src/http_parser.o./src./include/http_parser.h./include./Makefile./tags</p></blockquote><pre class="brush:cpp;gutter:false;"></pre><pre class="brush:cpp;gutter:false;">Makefile 如下 ： </pre><blockquote><p># makefile neededCC = gcc CPP = gcc -ECFLAGS = -I ./include -std=c99 -gSOURCES = $(wildcard src/*.c)HEADERS = OBJS = ${SOURCES:%.c=%.o}</p><p># self-definedBIN = ./bin/mainLIBS =</p><p>all: $(BIN) @echo "*****Make done*****" @echo "*****/bin/main*****" @echo "*******************"</p><p>$(BIN): $(OBJS) $(CXX) -o $@ $^ $(LIBS) -g</p><p>clean: rm -f $(OBJS) $(BIN)</p></blockquote><pre class="brush:cpp;gutter:false;"></pre><pre class="brush:cpp;gutter:false;">测试用例如下：</pre><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include "http_parser.h"#define BUF_LEN 1000#define DCB_CALLBACK(x) int http_##x##_callback(http_parser *parser, const char *at, size_t length)DCB_CALLBACK(header_field) {    #define CODES \    char str_buf[BUF_LEN];\    memcpy(str_buf, at, length);\    str_buf[length] = '\0';    CODES    printf("%s : ", str_buf);    return 0;}DCB_CALLBACK(header_value) {    CODES    printf("%s\n", str_buf);    return 0;}DCB_CALLBACK(body) {    CODES    printf("body : \n%s\n", str_buf);    return 0;}DCB_CALLBACK(url) {    CODES    printf("url : %s\n", str_buf);    return 0;}#define CB_CALLBACK(x) int http_##x##_callback(http_parser *parser)#define TOKEN "==================================="CB_CALLBACK(message_begin) {    printf("parser starts working , result below : \n"TOKEN"\n");    return 0;}CB_CALLBACK(message_complete) {    printf(TOKEN"\nparser ends\n");    return 0;}CB_CALLBACK(headers_complete) {    printf(TOKEN"\n");    return 0;}int main(int argc, char* argv[]) {    const char *http_req =     "GET http://cis.baidu.com/cis/cis.txt HTTP/1.1\r\n"    "Accept: */*\r\n"    "Accept-Encoding: gzip, deflate\r\n"    "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\r\n"    "Host: cis.baidu.com\r\n"    "Connection: Keep-Alive\r\n"    "Cookie: BAIDUID=1D87E461519AD9EB47411775459F0634:FG=1;\r\n\r\n";        const char *http_res =     "HTTP/1.1 200 OK\r\n"    "Server: nginx\r\n"    "Date: Wed, 07 Mar 2012 09:43:02 GMT\r\n"    "Content-Type: text/html; charset=utf-8\r\n"    "Connection: keep-alive\r\n"    "Vary: Accept-Encoding\r\n"    "Content-Encoding: gzip\r\n"    "Content-Length: 20\r\n\r\n12345678901234567890";    http_parser *parser = (http_parser*)malloc(sizeof(http_parser));    http_parser_settings *settings = (http_parser_settings*) malloc(sizeof(http_parser_settings));        #define NCB(n) http_##n##_callback    #define SCB(x) settings-&gt;on_##x = NCB(x)    SCB(url);    SCB(header_field);    SCB(header_value);    SCB(body);    SCB(message_begin);    SCB(headers_complete);    SCB(message_complete);    http_parser_init(parser, HTTP_REQUEST);    http_parser_execute(parser, settings, http_req, strlen(http_req));        http_parser_init(parser, HTTP_RESPONSE);    #define BIG_ENOUGH_BUF_LEN 10000    int ret = http_parser_execute(parser, settings, http_res, BIG_ENOUGH_BUF_LEN);    //printf("\nret : %d\n", ret);    return 0;}</pre>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>