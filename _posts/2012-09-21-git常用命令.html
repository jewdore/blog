---
layout: post
title: Git常用命令
---

<p>因为项目中用到了Git(GitHub)，而Git的命令，概念也比较多，我这里记录一下。</p>  1，概念  <p>Git是分布式版本控制系统，在本身Git的设计中没有所谓的中央库。当然在实际开发中我们一般会设定一个中央库以方便管理，比如GitHub上的库作为中央库。但是这不是Git强制的，是Best Practice，是我们为了方便管理在概念上设置的。这个中央库约定俗成叫做：origin。</p>  <p>Git中只有本地库和远端库(remote repository)。Git一般是三级级提交：</p>  <p>1, 我们先提交到暂存区(stage)，通git add&#160; .|filename</p>  <p>2, 再提交到本地库(这也是Git比SVN好的地方，适合频繁提交)，通过git commit –m “you comments here”</p>  <p>3, 最后当我们觉得需要将这些代码分享的时候我们在提交到远端库(remote)，通过git remote add&#160; [remote name]&#160; git://github.com/octocat/Spoon-Knife.git 添加远端库，通过git push [remotename]&#160; master将本地库的更新推送到远端库。</p>  <p>Git的metadata比较集中，在库所在的目录有一个.git目录，所有的metadata都在这个目录下。</p>  2，Git的配置  <p>git有三个配置文件，分别是repo/.git/config，$HOME/.gitconfig，/etc/gitconfig。</p>  <p>*repo/.git/config 库级别的配置文件，只对当前库有效，优先级最高(git config –local)</p>  <p>*$HOME/.gitconfig 用户级别的配置文件，对当前用户有效，优先级次之(git config –global)</p>  <p>*/etc/gitconfig 系统全局配置文件，对整个系统有效，优先级最低(git config –system)</p>  <blockquote>   <p>git config --list&#160;&#160;&#160; #查看当前有效配置</p>    <p>git config --global color.ui true&#160;&#160; #设置color.ui为true</p> </blockquote>  <p>git支持自动完成，也就是说你输入git conf然后按tab键，系统会自动扩展为git config。对于选项这依然有效，比如git config –global –color.[tab]你会看到许多可选项。</p>  3，查看命令  <p>1，查看Git当前库的状态</p>  <blockquote>   <p>git status [-s]&#160;&#160;&#160; # -s是简短的输出，左列是暂存区的状态，右边是工作区的状态</p> </blockquote>  <p>2，显示当前连接的remote repo</p>  <blockquote>   <p>git remote -v</p> </blockquote>  <p>3，显示branch，在Git中branch就是一个working context(工作上下文)，你可以很随意的新建一个branch来创建一个工作上下文。</p>  <blockquote>   <p>git branch&#160; [-v] </p> </blockquote>  <p>4，显示文件的每一行都是谁最后修改的</p>  <blockquote>   <p>git blame a-file.c</p> </blockquote>  <p>5，以简洁的方式显示branch的graph</p>  <blockquote>   <p>git log --graph --pretty=oneline&#160; [-5]&#160;&#160; # -5显示最近5笔log。</p> </blockquote>  <p>6，显示最近两次commit的详细信息，包括文件改动</p>  <blockquote>   <p>git log –p –2&#160;&#160;&#160;&#160;&#160; #-p会打印出改动的diff结果</p>    <p>git show &lt;commit-id&gt;&#160;&#160; #想看特定的commit</p> </blockquote>  3，本地库的操作  <p>1,创建版本库</p>  <blockquote>   <p>git init&#160; reponame&#160; #创建本地库</p>    <p>git clone git@github.com:jatsz/snippets.git&#160;&#160;&#160; #以远程clone的方式创建版本库</p> </blockquote>  <p>2，添加文件到暂存库(stage)</p>  <blockquote>   <p>git add file&#160;&#160; #将file加到版本库中，其实是stage中。</p>    <p>git add –u&#160;&#160; #将所有tracked files的更新添加到stage</p>    <p>git add .&#160;&#160;&#160;&#160;&#160; #注意这个点号，这是将所有改动添加到stage</p> </blockquote>  <p>3，将暂存库提交(commit)到本地库</p>  <blockquote>   <p>git commit –m “you comments”&#160;&#160; #将stage中的改动提交到本地库</p> </blockquote>  <p>&#160;</p>  4，远程库操作  <p>1，添加一个远程库</p>  <blockquote>   <p>git remote add upstream git://github.com/octocat/Spoon-Knife.git&#160;&#160; #新建一个远程库，并命名为upstream</p> </blockquote>  <p>2，从远程库获取代码</p>  <blockquote>   <p>git fetch upstream&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; #获取</p>    <p>git merge upstream/master&#160;&#160;&#160; #合并到当前开发分支，这步如果不做你看不到文件的更新，git status显示“Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.”</p> </blockquote>  <p>3，将本地更新Push到远程库</p>  <blockquote>   <p>git push upstream master&#160;&#160; #将本地master上传到upstream</p> </blockquote>  <p>4，删除远程库</p>  <blockquote>   <p>git remote rm upstream&#160;&#160; #删除名为upstream的远程库</p> </blockquote>  5，查看文件修改(diff)  <p>通常，我们的每个文件有4份影像：本地工作区，暂存区(stage)，本地版本库 (local repo)，远程版本库(remote repo)。所以我们通过不同的diff选项来比较不同位置的文件影像。</p>  <p>1，工作区与暂存区的比较</p>  <blockquote>   <p>git diff&#160; [file-name]</p> </blockquote>  <p>2，暂存区与本地库的比较</p>  <blockquote>   <p>git diff –cached [file-name]</p> </blockquote>  <p>3，工作区与本地库的比较</p>  <blockquote>   <p>git diff HEAD [file-name] 或 git diff master&#160; [file-name]&#160;&#160;&#160;&#160; #HEAD通常是master的别名</p> </blockquote>  <p>4，本地库与远程库的比较</p>  <p>这个比较麻烦些，我们先要获取远程源代码</p>  <blockquote>   <p>git fetch upstream&#160;&#160;&#160; #这里upstream是远程代码库</p>    <p>git diff master&#160;&#160; upstream/master</p> </blockquote>  6，撤销(reset)与反悔(revert)  <p>Git的撤销是指你叫工作区的修改加到暂存区的，你现在想把它撤回——不改变文件。反悔是指，你想用暂存区的影像(staged snapshot)覆盖工作区的文件。</p>  <p>Git中的撤销和反悔也要考虑到：工作区，暂存区，本地库。</p>  <p>1a，从暂存区撤销(Unstage)</p>  <blockquote>   <p>git reset – readme.txt #将readme.txt unstage，如果想unstage所有的文件直接 git reset</p> </blockquote>  <p>1b，从暂存区反悔，用暂存区文件覆盖工作区文件</p>  <blockquote>   <p>git checkout –&#160; readme.txt&#160;&#160;&#160; #你将丢失所有unstaged的修改</p> </blockquote>  <p>1c，从本地库反悔，用本地库的snapshot来覆盖工作区的文件</p>  <blockquote>   <p>git checkout HEAD – readme.txt&#160; #丢失所有staged和unstaged的修改</p> </blockquote>  <p>2a，从本地库撤销到暂存区(Undo commit)</p>  <blockquote>   <p>git reset –soft HEAD^&#160;&#160;&#160;&#160; #HEAD是指当前版本，HEAD^表示当前提交的上次提交，</p> </blockquote>  <p>2b，从本地库直接撤销到工作区(undo commit =&gt; undo stage)</p>  <blockquote>   <p>git reset –mixed HEAD^</p> </blockquote>  7，创建里程碑(tag)  <p>1，为最新的release创建一个里程碑</p>  <blockquote>   <p>git tag rev-1.1 –m “create tag for release v 1.1”</p> </blockquote>  8，杂项  <p>1，忽略一些文件：添加.gitignore文件</p>  <p>.gitignore文件的作用范围是当前文件夹和所有子文件夹。可以使用通配符。实例：</p>  <blockquote>   <p>.DS_Store      *.pyc       *.avi       *.mp4       *.wmv</p> </blockquote>  <p>2，不要轻易用git reset –hard</p>  <p>如果你想要恢复前面的版本，你可以先用git checkout HEAD^^ [—cached] – README 找出最近的更改，然后在git commit –m “delete added line to readme file”。</p>  <p>这样的好处是这个历史记录都保存的比较完整，log history的graph也比较好看懂。而你用git reset –hard HEAD^^会彻底丢失历史。如果你真这样做了只有这样找回历史记录了的：</p>  <blockquote>   <p>git reflog&#160; -10</p>    <p>git resest –hard HEAD@{2}</p> </blockquote>  <p>&#160;</p>  <p>   <hr /></p>  <p>Reference:</p>  <p>http://kb.cnblogs.com/page/132209/</p>  <p>http://book.douban.com/subject/6526452/&#160;&#160;&#160;&#160;&#160;&#160; --《Git权威指南》 蒋鑫</p>  <p>http://marklodato.github.com/visual-git-guide/index-en.html&#160; -- A Visual Git Reference</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>