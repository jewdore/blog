---
layout: post
title: Node.js源码研究之模块组织加载
---

<p>Node.js源码研究之模块组织加载 - 51CTO.COM</p><blockquote><p>粗略研究了一下node.js源码，它有8000行C++代码，2000行javascript代码，来看看js和C++间是怎么组织连接起来，以及各个模块是怎样互相调用的。</p><p>本文使用的node.js版本是0.4.8，可以在https://github.com/joyent/node/tree/v0.4.8这里看到源码。</p><p>js2c.py</p><p>node.js使用了V8附带的js2c.py工具把所有内置的js代码转换成C++里的数组，生成node_natives.h直接include到程序中，成了C++源码的一部分。这样做能提高内置js模块的编译效率。</p><p>node.js里内置的javascript包括了主程序src/node.js和模块程序lib/*.js，通过js2c.py让每一个js文件都生成一个源码数组，存放在build/src/node_natives.h里，node_natives.h在node.js编译后才会生成(编译的脚本wscript中调用了js2c.py)，可以看到大致的结构如下：</p><pre><ol class="dp-c"><li class="alt">namespacenode{ constcharnode_native[]={47,47,32,67,112......} <li class="alt">constcharconsole_native[]={47,47,32,67,112......} constcharbuffer_native[]={47,47,32,67,112......} <li class="alt">..... } <li class="alt">struct_native{constchar*name;constchar*source;size_tsource_len;}; staticconststruct_nativenatives[]={ <li class="alt">{"node",node_native,sizeof(node_native)-1}, {"dgram",dgram_native,sizeof(dgram_native)-1}, <li class="alt">{"console",console_native,sizeof(console_native)-1}, {"buffer",buffer_native,sizeof(buffer_native)-1}, <li class="alt">.... }</ol></pre><p>这个文件被包含在node_javascript.cc里，node_javascript.cc提供了两个接口：</p><p>MainSource() 处理node_native源码返回v8::Handle类型的数据可供编译。</p><p>DefineJavaScript(target) 把其他所有模块源码变成v8::Handle类型后加载到传入的target对象上。</p><p>所有的js模块都被转换成了C数组，接下来看看它们怎么执行和互相调用。</p><p>执行js主程序/传递process</p><p>先看看node.js的底层C++传递给javascript的一个变量process，在一开始运行node.js时，程序会先配置好process</p><pre><ol class="dp-c"><li class="alt">Handleprocess=SetupProcessObject(argc,argv);</ol></pre><p>然后把process作为参数去调用js主程序src/node.js返回的函数，这样process就传递到javascript里了。</p><pre><ol class="dp-c"><li class="alt">//node.cc //通过MainSource()获取已转化的src/node.js源码，并执行它 <li class="alt">Localf_value=ExecuteString(MainSource(),IMMUTABLE_STRING("node.js")); <li class="alt">//执行src/node.js后获得的是一个函数，从node.js源码可以看出： //node.js <li class="alt">//(function(process){ //global=this; <li class="alt">//.... //}) <li class="alt">Localf=Local::Cast(f_value); <li class="alt">//创建函数执行环境，调用函数，把process传入 <li class="alt">Localglobal=v8::Context::GetCurrent()-&gt;Global(); Localargs[1]={Local::New(process)}; <li class="alt">f-&gt;Call(global,1,args);</ol></pre><p>C++模块</p><p>node.js的模块除了lib/*.js里用js语言编写的以外，还有一些使用C++编写，像os/stdio/crypto/buffer等。这些模块都通过node.h提供的NODE_MODULE方法存储在变量_module里。node_extensions.cc提供了get_builtin_module(name)接口获取这些模块。</p><p>process.binding/C++模块加载</p><p>process提供的一个获取模块的接口是binding，它的实现Binding()函数可以在node.cc找到。</p><pre><ol class="dp-c"><li class="alt">Persistentbinding_cache; staticHandleBinding(constArguments&amp;args){ <li class="alt">HandleScopescope; Localmodule=args[0]-&gt;ToString(); <li class="alt">String::Utf8Valuemodule_v(module); node_module_struct*modp; <li class="alt">if(binding_cache.IsEmpty()){ <li class="alt">binding_cache=Persistent::New(Object::New()); } <li class="alt">Localexports; if(binding_cache-&gt;Has(module)){ <li class="alt">exports=binding_cache-&gt;Get(module)-&gt;ToObject(); <li class="alt">}elseif((modp=get_builtin_module(*module_v))!=NULL){ exports=Object::New(); <li class="alt">modp-&gt;register_func(exports); binding_cache-&gt;Set(module,exports); <li class="alt">}elseif(!strcmp(*module_v,"constants")){ <li class="alt">exports=Object::New(); DefineConstants(exports); <li class="alt">binding_cache-&gt;Set(module,exports); <li class="alt">#ifdef__POSIX__ }elseif(!strcmp(*module_v,"io_watcher")){ <li class="alt">exports=Object::New(); IOWatcher::Initialize(exports); <li class="alt">binding_cache-&gt;Set(module,exports); #endif <li class="alt">}elseif(!strcmp(*module_v,"natives")){ <li class="alt">exports=Object::New(); DefineJavaScript(exports); <li class="alt">binding_cache-&gt;Set(module,exports); <li class="alt">}else{ <li class="alt">returnThrowException(Exception::Error(String::New("Nosuchmodule"))); } <li class="alt">returnscope.Close(exports); }</ol></pre><p>从源码可以看到，调用process.binding时，先看缓存里是否已经存在此模块，不存在再调用get_builtin_module查找C++内置模块，找到的话获取后绑定在exports上，在最后返回exports。</p><p>此外还有针对其他模块的特殊处理，其中natives模块就是调用上文提到的DefineJavaScript(exports)接口获取到所有内置的js模块绑定在exports上。</p><p>现在在js上需要调用C++提供的模块只需要调用process.binding就行了，例如</p><pre><ol class="dp-c"><li class="alt">varstdio=﻿process.binding("stdio")</ol></pre><p>js模块加载</p><p>src/node.js上实现了一个NativeModule对象用于管理js模块，它通过调用process.binding(&#8220;natives&#8221;)把所有内置的js模块放在NativeModule._source上，并提供require接口供调用。在require里会给代码加一层包装，把一些变量传给这个模块。</p><pre><ol class="dp-c"><li class="alt">NativeModule.wrapper=[ '(function(exports,require,module,__filename,__dirname){', <li class="alt">'\n});'];</ol></pre><p>再用process提供的其中一个js编译接口process.runInThisContext执行代码。</p><pre><ol class="dp-c"><li class="alt">varfn=runInThisContext(source,this.filename,true); fn(this.exports,NativeModule.require,this,this.filename);</ol></pre><p>于是在主程序src/node.js上可以调用NativeModule.require(&#8220;net&#8221;)去加载net模块，在lib/*.js的各个js模块里能通过调用传进来的require()去加载其他内置js模块。</p><p>总结流程</p><p>粗略总结一下加载模块的流程：</p><p>加载C++模块(以stdio为例)：</p><p>process.binding(&#8220;stdio&#8221;) -&gt; get_builtin_module(&#8220;stdio&#8221;) -&gt; _module -&gt; NODE_MODULE(node_stdio, node::Stdio::Initialize)(定义)</p><p>加载js模块(以net为例)</p><p>require(&#8220;net&#8221;) -&gt; NativeModule.require(&#8220;net&#8221;) -&gt; process.binding(&#8220;natives&#8221;)["net"] -&gt; DefineJavaScript() -&gt; natives[] -&gt; node_natives.h</p><p>原文：http://cnodejs.org/blog/?p=1280</p></blockquote>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>