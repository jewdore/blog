---
layout: post
title: 【转】Nginx与长连接服务—低延迟信息推送
---

<p>http://bigtoy4boy.com/blog/tag/nginx/</p><p>服务器推送（Server Push）是高效的、延迟低的数据交换方式。如果数据发送端与接收端都在互联网中公开可见，可以使用PubSubHubbub或simpler Webhook等方法完成任务。但是如果数据接收方在防火墙内、在内网或它只是一个浏览器（只可以向外发送数据请求，无法处理传入的数据），则实现服务器推送就更难了。如果你有冒险精神，你可以建立一个反向HTTP服务器。如果你寻求可靠的解决方案，也许你要等待HTML5的WebSocket&rsquo;s API特性了。但如果你需要即刻可以实现的解决方案，你可以妥协一下，使用异步推送模式来代替，你可以使用Comet，也被称为反向Ajax、HTTP服务器推送或HTTP流。</p><p>早在2006年Alex Russel提出了一个不坏的技术思路，那就是长连接（Comet）概念：从客户端发起并保持一个连接直到数据出现并传送（long polling），或者永远保持一个连接，通过它推送数据到客户端（streaming）。这两种方法的好处是数据传送非常及时。因此长连接技术广泛用于聊天应用（Facebook, Google, Meebo等）以及实现即时触发的机制。</p><p>将Nginx变成一个长连接服务器</p><p>实现长连接服务比较大的问题是特殊的隐形需求以及事件驱动web服务器能否高效处理众多的长连接。Friendfeed的Tornado服务器是一个标准应用级服务器的好例子。另外，感谢Leo Ponomarev的努力，你现在可以用nginx_http_push_module插件使你的Nginx服务器变身成为一台完全功能的长连接服务器。</p><p>使用自定义的一套框架结构，Leo的插件只提供两个对外的接口：一个是订阅者，一个是发布者。客户端连接Nginx服务器，创建针对一个频道的long-polling长连接并等待数据。同时，发布者只是简单的将数据使用POST方法提交给Nginx，插件收到数据后将它一个个发给等待的客户端。这表明发布者不需要直接传递数据，它只是一个简单的事件产生器！没有比这个更简单的方法了。</p><p>还有更高的功能是，客户端和发布端可以建立任意的频道，并且插件也提供消息队列功能，这表明Nginx服务器会在客户端断线的情况下临时保存消息。队列消息可以按照时间、等待列表长度或内存限制大小来失效释放。</p><p>Nginx和Ruby配置例子</p><p>一开始，你需要从源代码编译一个Nginx。解压源代码包，从GitHub获取插件的源码并放入Nginx的源码目录，然后使用下面的参数编译（./configure &ndash;add-module=/path/to/plugin &amp;&amp; make &amp;&amp; make install）。下一步，参考readme文件和协议文件，了解所有的参数选项。一个多客户端接收信息的配置例子如下：</p><p><em>#</em><em>内部发布点（保证私有或不对外公开）</em></p><p>location /publish{</p><p>set$push_channel_id$arg_id;<em>#/?id=239aff3</em><em>或类似的文本标示</em></p><p>push_sender;</p><p>push_store_messages on;<em>#</em><em>打开消息队列</em></p><p>push_message_timeout 2h;<em># 2</em><em>小时后消息失效</em></p><p>push_max_message_buffer_length 10;<em>#</em><em>保存10条消息</em></p><p>push_min_message_recipients 0;<em>#</em><em>清除前最小接收人数目</em></p><p>}</p><p><em>#</em><em>公开的长连接接收点</em></p><p>location /activity{</p><p>push_listener;</p><p><em>#</em><em>一个频道编号能有多少客户端同时连接</em></p><p><em># &ndash; last:</em><em>只有最频繁请求的客户端能保持，其它连接返回409</em></p><p><em># &ndash; first:</em><em>只有最早连接的那个客户端可以保持，其它连接返回409</em></p><p><em># &ndash; broadcast:</em><em>任何数量的客户端连接都会是长连接</em></p><p>push_listener_concurrency broadcast;</p><p>set$push_channel_id$arg_id;</p><p>default_type text/plain;</p><p>}</p><p>当你编译配置好你的Nginx服务器，并且启动它，我们可以建立一个简单的广播场景，一个数据发送广播方，几个订阅信息接收方来测试我们的长连接服务器。</p><p>require&lsquo;rubygems&rsquo;</p><p>require&lsquo;em-http&rsquo;</p><p>defsubscribe(opts)</p><p>listener =EventMachine::HttpRequest.new(&lsquo;http://127.0.0.1/activity?id=&rsquo;+ opts[:channel]).get:head=&gt; opts[:head]</p><p>listener.callback{</p><p><em>#</em><em>打印所获取的内容，并重新订阅这个频道</em></p><p><em>#</em><em>使用last-modified头去忽略之前已经获取的数据。</em></p><p>puts&ldquo;Listener recieved: &rdquo; + listener.response + &ldquo;\\n&rdquo;</p><p>modified = listener.response_header['LAST_MODIFIED']</p><p>subscribe({:channel =&gt; opts[:channel],:head=&gt;{&lsquo;If-Modified-Since&rsquo; =&gt; modified}})</p><p>}</p><p>end</p><p>EventMachine.run{</p><p>channel = &ldquo;pub&rdquo;</p><p><em>#</em><em>每5秒钟发布一个新的消息</em></p><p>EM.add_periodic_timer(5)do</p><p>time =Time.now</p><p>publisher =EventMachine::HttpRequest.new(&lsquo;http://127.0.0.1/publish?id=&rsquo;+channel).post:body=&gt; &ldquo;Hello @ #{time}&rdquo;</p><p>publisher.callback{</p><p>puts&ldquo;Published message @ #{time}&rdquo;</p><p>puts&ldquo;Response code: &rdquo; + publisher.response_header.status.to_s</p><p>puts&ldquo;Headers: &rdquo; + publisher.response_header.inspect</p><p>puts&ldquo;Body: \\n&rdquo; + publisher.response</p><p>puts&ldquo;\\n&rdquo;</p><p>}</p><p>end</p><p><em>#</em><em>打开两个客户端</em></p><p>subscribe(:channel=&gt; channel)</p><p>subscribe(:channel=&gt; channel)</p><p>}</p><p>nginx-push.zip (完整的Nginx配置和Ruby代码)</p><p>在上面的代码中，每5秒钟数据发布端向Nginx服务器发出新的事件，服务器将数据通过长连接转发给两个订阅的客户端。当消息发送到客户端，服务器会断开他们的连接，客户端会立即重连并等待下一次数据的到来。结果就是使用Nginx实现了一个数据发布端到客户端的实时消息推送机制！</p><p>期待生产环境下的长连接服务</p><p>Leo的模块还在开发期，还需要时间来稳定下来，但它是一个需要关注的项目。最近的更新计划都着重于bug修复，未来的计划里有描述要加入流的模式：代替现在每次数据获取后都要重连的情况（long polling），Nginx会保持连接，将数据一段段的实时传送给客户端。拥有这个功能后你能很方便的部署你自己的信息触发式API（例如：Twitter流）。</p><p>最后，不要忘记数字不断增长的其它Nginx模块，或者如果你感兴趣的话，可以参考Evan Miller编写的指引来开发自己的Nginx模块。</p>

了解破碎机常识：<a href='http://www.crushermillsupplier.com'>crusher mill supplier</a>